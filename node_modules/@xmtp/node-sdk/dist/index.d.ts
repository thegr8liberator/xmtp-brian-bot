import * as _xmtp_node_bindings from '@xmtp/node-bindings';
import { NapiMessage, NapiGroup, NapiListMessagesOptions, NapiConsentState, NapiConversations, NapiCreateGroupOptions, NapiListConversationsOptions, NapiClient, NapiSignatureRequestType, NapiConsent, NapiConsentEntityType } from '@xmtp/node-bindings';
export * from '@xmtp/node-bindings';
import { ContentTypeId, ContentCodec, EncodedContent } from '@xmtp/content-type-primitives';

type ResolveValue<T> = {
    value: T | undefined;
    done: boolean;
    error: Error | null;
};
type StreamCallback<T> = (err: Error | null, value: T) => void;
declare class AsyncStream<T> {
    #private;
    stopCallback: (() => void) | undefined;
    constructor();
    get isDone(): boolean;
    callback: StreamCallback<T>;
    stop: (error?: Error) => void;
    next: () => Promise<ResolveValue<T>>;
    [Symbol.asyncIterator](): this;
}

type MessageKind = "application" | "membership_change";
type MessageDeliveryStatus = "unpublished" | "published" | "failed";
declare class DecodedMessage<T = any> {
    #private;
    content: T;
    contentType: ContentTypeId | undefined;
    conversationId: string;
    deliveryStatus: MessageDeliveryStatus;
    fallback?: string;
    compression?: number;
    id: string;
    kind: MessageKind;
    parameters: Record<string, string>;
    senderInboxId: string;
    sentAt: Date;
    sentAtNs: number;
    constructor(client: Client, message: NapiMessage);
}

declare class Conversation {
    #private;
    constructor(client: Client, group: NapiGroup);
    get id(): string;
    get name(): string;
    updateName(name: string): Promise<void>;
    get imageUrl(): string;
    updateImageUrl(imageUrl: string): Promise<void>;
    get description(): string;
    updateDescription(description: string): Promise<void>;
    get pinnedFrameUrl(): string;
    updatePinnedFrameUrl(pinnedFrameUrl: string): Promise<void>;
    get isActive(): boolean;
    get addedByInboxId(): string;
    get createdAtNs(): number;
    get createdAt(): Date;
    get metadata(): {
        creatorInboxId: string;
        conversationType: string;
    };
    members(): Promise<_xmtp_node_bindings.NapiGroupMember[]>;
    get admins(): string[];
    get superAdmins(): string[];
    get permissions(): {
        policyType: _xmtp_node_bindings.NapiGroupPermissionsOptions;
        policySet: _xmtp_node_bindings.NapiPermissionPolicySet;
    };
    isAdmin(inboxId: string): boolean;
    isSuperAdmin(inboxId: string): boolean;
    sync(): Promise<void>;
    stream(callback?: StreamCallback<DecodedMessage>): AsyncStream<DecodedMessage<any>>;
    addMembers(accountAddresses: string[]): Promise<void>;
    addMembersByInboxId(inboxIds: string[]): Promise<void>;
    removeMembers(accountAddresses: string[]): Promise<void>;
    removeMembersByInboxId(inboxIds: string[]): Promise<void>;
    addAdmin(inboxId: string): Promise<void>;
    removeAdmin(inboxId: string): Promise<void>;
    addSuperAdmin(inboxId: string): Promise<void>;
    removeSuperAdmin(inboxId: string): Promise<void>;
    publishMessages(): Promise<void>;
    sendOptimistic(content: any, contentType?: ContentTypeId): string;
    send(content: any, contentType?: ContentTypeId): Promise<string>;
    messages(options?: NapiListMessagesOptions): DecodedMessage[];
    get consentState(): NapiConsentState;
    updateConsentState(consentState: NapiConsentState): void;
    get dmPeerInboxId(): string;
}

declare class Conversations {
    #private;
    constructor(client: Client, conversations: NapiConversations);
    getConversationById(id: string): Conversation | null;
    getDmByInboxId(inboxId: string): Conversation | null;
    getMessageById<T = any>(id: string): DecodedMessage<T> | null;
    newConversation(accountAddresses: string[], options?: NapiCreateGroupOptions): Promise<Conversation>;
    newDm(accountAddress: string): Promise<Conversation>;
    list(options?: NapiListConversationsOptions): Promise<Conversation[]>;
    listGroups(options?: Omit<NapiListConversationsOptions, "conversationType">): Promise<Conversation[]>;
    listDms(options?: Omit<NapiListConversationsOptions, "conversationType">): Promise<Conversation[]>;
    sync(): Promise<void>;
    stream(callback?: StreamCallback<Conversation>): AsyncStream<Conversation>;
    streamGroups(callback?: StreamCallback<Conversation>): AsyncStream<Conversation>;
    streamDms(callback?: StreamCallback<Conversation>): AsyncStream<Conversation>;
    streamAllMessages(callback?: StreamCallback<DecodedMessage>): Promise<AsyncStream<DecodedMessage<any>>>;
    streamAllGroupMessages(callback?: StreamCallback<DecodedMessage>): Promise<AsyncStream<DecodedMessage<any>>>;
    streamAllDmMessages(callback?: StreamCallback<DecodedMessage>): Promise<AsyncStream<DecodedMessage<any>>>;
}

declare const ApiUrls: {
    readonly local: "http://localhost:5556";
    readonly dev: "https://grpc.dev.xmtp.network:443";
    readonly production: "https://grpc.production.xmtp.network:443";
};
type XmtpEnv = keyof typeof ApiUrls;
/**
 * Network options
 */
type NetworkOptions = {
    /**
     * Specify which XMTP environment to connect to. (default: `dev`)
     */
    env?: XmtpEnv;
    /**
     * apiUrl can be used to override the `env` flag and connect to a
     * specific endpoint
     */
    apiUrl?: string;
};
/**
 * Storage options
 */
type StorageOptions = {
    /**
     * Encryption key to use for the local DB
     */
    encryptionKey?: Uint8Array | null;
    /**
     * Path to the local DB
     */
    dbPath?: string;
};
type ContentOptions = {
    /**
     * Allow configuring codecs for additional content types
     */
    codecs?: ContentCodec[];
};
type OtherOptions = {
    /**
     * Optionally set the request history sync URL
     */
    requestHistorySync?: string;
    /**
     * Optionally set the logging level (default: 'off')
     */
    logging?: "debug" | "info" | "warn" | "error" | "off";
};
type ClientOptions = NetworkOptions & StorageOptions & ContentOptions & OtherOptions;
declare class Client {
    #private;
    constructor(client: NapiClient, codecs: ContentCodec[]);
    static create(accountAddress: string, options?: ClientOptions): Promise<Client>;
    get accountAddress(): string;
    get inboxId(): string;
    get installationId(): string;
    get isRegistered(): boolean;
    createInboxSignatureText(): Promise<string | null>;
    addWalletSignatureText(existingAccountAddress: string, newAccountAddress: string): Promise<string | null>;
    revokeWalletSignatureText(accountAddress: string): Promise<string | null>;
    revokeInstallationsSignatureText(): Promise<string | null>;
    canMessage(accountAddresses: string[]): Promise<Record<string, boolean>>;
    addSignature(signatureType: NapiSignatureRequestType, signatureBytes: Uint8Array): void;
    applySignatures(): Promise<void>;
    registerIdentity(): Promise<void>;
    get conversations(): Conversations;
    codecFor(contentType: ContentTypeId): ContentCodec | undefined;
    encodeContent(content: any, contentType: ContentTypeId): EncodedContent<Record<string, string>>;
    decodeContent(message: NapiMessage, contentType: ContentTypeId): any;
    requestHistorySync(): Promise<void>;
    getInboxIdByAddress(accountAddress: string): Promise<string | null>;
    inboxState(refreshFromNetwork?: boolean): Promise<_xmtp_node_bindings.NapiInboxState>;
    getLatestInboxState(inboxId: string): Promise<_xmtp_node_bindings.NapiInboxState>;
    inboxStateFromInboxIds(inboxIds: string[], refreshFromNetwork?: boolean): Promise<_xmtp_node_bindings.NapiInboxState[]>;
    setConsentStates(consentStates: NapiConsent[]): Promise<void>;
    getConsentState(entityType: NapiConsentEntityType, entity: string): Promise<_xmtp_node_bindings.NapiConsentState>;
}

declare const generateInboxId: (accountAddress: string) => string;
declare const getInboxIdForAddress: (accountAddress: string, env?: XmtpEnv) => Promise<string | null>;

export { ApiUrls, Client, type ClientOptions, Conversation, Conversations, DecodedMessage, type NetworkOptions, type OtherOptions, type StorageOptions, type StreamCallback, type XmtpEnv, generateInboxId, getInboxIdForAddress };
