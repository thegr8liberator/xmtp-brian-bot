import{ciphertext as e,privateKey as t,signature as s,publicKey as r,fetcher as n,keystore as i,message as a,content as o,authn as c,messageApi as d,invitation as h,privatePreferences as y,contact as u}from"@xmtp/proto";import l from"long";import*as p from"@noble/secp256k1";import{bytesToHex as w,keccak256 as f,getAddress as m,hexToSignature as g,hexToBytes as v,hashMessage as b,verifyMessage as E}from"viem";import{ContentTypeText as K,TextCodec as k}from"@xmtp/content-type-text";import{ContentTypeId as P}from"@xmtp/content-type-primitives";import{Mutex as S}from"async-mutex";import A from"elliptic";import T,{user_preferences_encrypt as C,user_preferences_decrypt as I,generate_private_preferences_topic as B}from"@xmtp/user-preferences-bindings-wasm/web";import{createConsentMessage as R}from"@xmtp/consent-proof-signature";class N{constructor(e){if(!e.aes256GcmHkdfSha256)throw new Error("invalid ciphertext");if(e.aes256GcmHkdfSha256.payload.length<16)throw new Error(`invalid ciphertext ciphertext length: ${e.aes256GcmHkdfSha256.payload.length}`);if(32!==e.aes256GcmHkdfSha256.hkdfSalt.length)throw new Error(`invalid ciphertext salt length: ${e.aes256GcmHkdfSha256.hkdfSalt.length}`);if(12!==e.aes256GcmHkdfSha256.gcmNonce.length)throw new Error(`invalid ciphertext nonce length: ${e.aes256GcmHkdfSha256.gcmNonce.length}`);this.aes256GcmHkdfSha256=e.aes256GcmHkdfSha256}toBytes(){return e.Ciphertext.encode(this).finish()}static fromBytes(t){return new N(e.Ciphertext.decode(t))}}const D=window.crypto,M=(new Uint8Array).buffer,x=(new Uint8Array).buffer;async function _(e){return new Uint8Array(await D.subtle.digest("SHA-256",e))}async function V(e,t,s){const r=D.getRandomValues(new Uint8Array(32)),n=D.getRandomValues(new Uint8Array(12)),i=await q(t,r),a=await D.subtle.encrypt(O(n,s),i,e);return new N({aes256GcmHkdfSha256:{payload:new Uint8Array(a),hkdfSalt:r,gcmNonce:n}})}async function U(e,t,s){if(!e.aes256GcmHkdfSha256)throw new Error("invalid payload ciphertext");const r=await q(t,e.aes256GcmHkdfSha256.hkdfSalt),n=await D.subtle.decrypt(O(e.aes256GcmHkdfSha256.gcmNonce,s),r,e.aes256GcmHkdfSha256.payload);return new Uint8Array(n)}function O(e,t){const s={name:"AES-GCM",iv:e};return t&&(s.additionalData=t),s}async function q(e,t){const s=await D.subtle.importKey("raw",e,"HKDF",!1,["deriveKey"]);return D.subtle.deriveKey({name:"HKDF",hash:"SHA-256",salt:t,info:M},s,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}async function L(e,t){const s=await D.subtle.importKey("raw",e,"HKDF",!1,["deriveKey"]);return D.subtle.deriveKey({name:"HKDF",hash:"SHA-256",salt:x,info:t},s,{name:"HMAC",hash:"SHA-256",length:256},!0,["sign","verify"])}async function G(e,t,s){const r=await L(e,t),n=await D.subtle.sign("HMAC",r,s);return new Uint8Array(n)}async function H(e,t,s){return await D.subtle.verify("HMAC",e,t,s)}async function F(e){const t=await D.subtle.exportKey("raw",e);return new Uint8Array(t)}async function $(e){return D.subtle.importKey("raw",e,{name:"HMAC",hash:"SHA-256",length:256},!0,["sign","verify"])}const j=p.utils.bytesToHex;function X(e,t){if(e.length!==t.length)return!1;for(let s=0;s<e.length;s++)if(e[s]!==t[s])return!1;return!0}function J(e){const t=g(e),s=v(t.r),r=v(t.s);let n=Number(t.v);0!==n&&1!==n||(n+=27);const i=1-n%2,a=new Uint8Array(64);return a.set(s),a.set(r,s.length),{bytes:a,recovery:i}}function z(e){if(32!==e.bytes.length)throw new Error(`invalid private key length: ${e.bytes.length}`)}class W{constructor(e){if(!e.secp256k1)throw new Error("invalid private key");if(z(e.secp256k1),this.secp256k1=e.secp256k1,this.createdNs=e.createdNs,!e.publicKey)throw new Error("missing public key");this.publicKey=new ae(e.publicKey)}static async generate(e){const t={bytes:p.utils.randomPrivateKey()},s=l.fromNumber((new Date).getTime()).mul(1e6),r=new ie({secp256k1Uncompressed:{bytes:p.getPublicKey(t.bytes)},createdNs:s}),n=await e.signKey(r);return new W({secp256k1:t,createdNs:s,publicKey:n})}generated(){return new Date(this.createdNs.div(1e6).toNumber())}async sign(e){const[t,s]=await p.sign(e,this.secp256k1.bytes,{recovered:!0,der:!1});return new te({ecdsaCompact:{bytes:t,recovery:s}})}async signKey(e){const t=e.toBytes(),s=await _(t),r=await this.sign(s);return new ae({keyBytes:t,signature:r})}static async signerKey(e,t){return ee(await _(e.bytesToSign()),t)}sharedSecret(e){return p.getSharedSecret(this.secp256k1.bytes,e.secp256k1Uncompressed.bytes,!1)}encrypt(e,t,s){return V(e,this.sharedSecret(t),s)}decrypt(e,t,s){return U(e,this.sharedSecret(t),s)}matches(e){return this.publicKey.equals(e)}equals(e){return X(this.secp256k1.bytes,e.secp256k1.bytes)&&this.publicKey.equals(e.publicKey)}toBytes(){return t.SignedPrivateKey.encode(this).finish()}validatePublicKey(){return X(p.getPublicKey(this.secp256k1.bytes),this.publicKey.secp256k1Uncompressed.bytes)}static fromBytes(e){return new W(t.SignedPrivateKey.decode(e))}static fromLegacyKey(e,t){return new W({createdNs:e.timestamp.mul(1e6),secp256k1:e.secp256k1,publicKey:ae.fromLegacyKey(e.publicKey,t)})}}class Y{constructor(e){if(!e.secp256k1)throw new Error("invalid private key");if(z(e.secp256k1),this.timestamp=e.timestamp,this.secp256k1=e.secp256k1,!e.publicKey)throw new Error("missing public key");this.publicKey=new oe(e.publicKey)}static generate(){const e={bytes:p.utils.randomPrivateKey()},t=l.fromNumber((new Date).getTime());return new Y({secp256k1:e,timestamp:t,publicKey:new oe({secp256k1Uncompressed:{bytes:p.getPublicKey(e.bytes)},timestamp:t})})}generated(){return new Date(this.timestamp.toNumber())}async sign(e){const[t,s]=await p.sign(e,this.secp256k1.bytes,{recovered:!0,der:!1});return new te({ecdsaCompact:{bytes:t,recovery:s}})}async signKey(e){const t=await _(e.bytesToSign());return e.signature=await this.sign(t),e}sharedSecret(e){return p.getSharedSecret(this.secp256k1.bytes,e.secp256k1Uncompressed.bytes,!1)}encrypt(e,t,s){return V(e,this.sharedSecret(t),s)}decrypt(e,t,s){return U(e,this.sharedSecret(t),s)}matches(e){return this.publicKey.equals(e)}validatePublicKey(){return X(p.getPublicKey(this.secp256k1.bytes),this.publicKey.secp256k1Uncompressed.bytes)}toBytes(){return t.PrivateKey.encode(this).finish()}static fromBytes(e){return new Y(t.PrivateKey.decode(e))}}function Q(e){if(64!==e.bytes.length)throw new Error(`invalid signature length: ${e.bytes.length}`);if(0!==e.recovery&&1!==e.recovery)throw new Error(`invalid recovery bit: ${e.recovery}`)}function Z(e,t){return e.recovery===t.recovery&&X(e.bytes,t.bytes)}function ee(e,t){const s=p.recoverPublicKey(e,t.bytes,t.recovery);return s?new ie({secp256k1Uncompressed:{bytes:s},createdNs:l.fromNumber(0)}):void 0}class te{constructor(e){if(e.ecdsaCompact)Q(e.ecdsaCompact),this.ecdsaCompact=e.ecdsaCompact;else{if(!e.walletEcdsaCompact)throw new Error("invalid signature");Q(e.walletEcdsaCompact),this.walletEcdsaCompact=e.walletEcdsaCompact}}async signerKey(e){return this.ecdsaCompact?W.signerKey(e,this.ecdsaCompact):this.walletEcdsaCompact?re.signerKey(e,this.walletEcdsaCompact):void 0}getPublicKey(e){let t;if(this.ecdsaCompact)t=p.recoverPublicKey(e,this.ecdsaCompact.bytes,this.ecdsaCompact.recovery);else{if(!this.walletEcdsaCompact)throw new Error("invalid v1 signature");t=p.recoverPublicKey(e,this.walletEcdsaCompact.bytes,this.walletEcdsaCompact.recovery)}return t?new oe({secp256k1Uncompressed:{bytes:t},timestamp:l.fromNumber(0)}):void 0}equals(e){return this.ecdsaCompact&&e.ecdsaCompact?Z(this.ecdsaCompact,e.ecdsaCompact):!(!this.walletEcdsaCompact||!e.walletEcdsaCompact)&&Z(this.walletEcdsaCompact,e.walletEcdsaCompact)}toBytes(){return s.Signature.encode(this).finish()}static fromBytes(e){return new te(s.Signature.decode(e))}}var se;!function(e){e[e.INBOX_KEY=0]="INBOX_KEY",e[e.SEND_KEY=1]="SEND_KEY"}(se||(se={}));class re{constructor(e){this.wallet=e}static identitySigRequestText(e){return`XMTP : Create Identity\n${j(e)}\n\nFor more info: https://xmtp.org/signatures/`}static signerKey(e,t){return ee(v(b(this.identitySigRequestText(e.bytesToSign()))),t)}async signKey(e){const t=e.toBytes(),s=await this.wallet.signMessage(re.identitySigRequestText(t)),{bytes:r,recovery:n}=J(s),i=new te({walletEcdsaCompact:{bytes:r,recovery:n}});return new ae({keyBytes:t,signature:i})}}const ne=new l(10**9).mul(10**9);class ie{constructor(e){if(!e?.secp256k1Uncompressed)throw new Error("invalid public key");!function(e){if(65!==e.bytes.length)throw new Error(`invalid public key length: ${e.bytes.length}`);if(4!==e.bytes[0])throw new Error(`unrecognized public key prefix: ${e.bytes[0]}`)}(e.secp256k1Uncompressed),this.secp256k1Uncompressed=e.secp256k1Uncompressed,this.createdNs=e.createdNs.toUnsigned()}generated(){return new Date(this.timestamp.toNumber())}isFromLegacyKey(){return this.createdNs.lessThan(ne)}get timestamp(){return(this.isFromLegacyKey()?this.createdNs:this.createdNs.div(1e6)).toUnsigned()}verify(e,t){return!!e.ecdsaCompact&&p.verify(e.ecdsaCompact.bytes,t,this.secp256k1Uncompressed.bytes)}async verifyKey(e){if(!e.signature)return!1;const t=await _(e.bytesToSign());return this.verify(e.signature,t)}equals(e){return X(this.secp256k1Uncompressed.bytes,e.secp256k1Uncompressed.bytes)}getEthereumAddress(){return function(e){const t=w(e.slice(1)),s=f(t),r=s.substring(s.length-40);return m(`0x${r}`)}(this.secp256k1Uncompressed.bytes)}toBytes(){return r.UnsignedPublicKey.encode(this).finish()}static fromBytes(e){return new ie(r.UnsignedPublicKey.decode(e))}}class ae extends ie{constructor(e){if(!e.keyBytes)throw new Error("missing key bytes");if(super(r.UnsignedPublicKey.decode(e.keyBytes)),this.keyBytes=e.keyBytes,!e.signature)throw new Error("missing key signature");this.signature=new te(e.signature)}get unsignedKey(){return new ie({createdNs:this.createdNs,secp256k1Uncompressed:this.secp256k1Uncompressed})}signerKey(){return this.signature.signerKey(this)}async walletSignatureAddress(){if(!this.signature.walletEcdsaCompact)throw new Error("key was not signed by a wallet");const e=await this.signerKey();if(!e)throw new Error("key signature not valid");return e.getEthereumAddress()}equals(e){return this.unsignedKey.equals(e.unsignedKey)&&this.signature.equals(e.signature)}bytesToSign(){return this.keyBytes}toBytes(){return r.SignedPublicKey.encode(this).finish()}static fromBytes(e){return new ae(r.SignedPublicKey.decode(e))}toLegacyKey(){if(!this.isFromLegacyKey())throw new Error("cannot be converted to legacy key");let e=this.signature;return e.walletEcdsaCompact&&(e=new te({ecdsaCompact:e.walletEcdsaCompact})),new oe({timestamp:this.timestamp,secp256k1Uncompressed:this.secp256k1Uncompressed,signature:e})}static fromLegacyKey(e,t){if(!e.signature)throw new Error("key is not signed");let s=e.signature;return t&&(s=new te({walletEcdsaCompact:s.ecdsaCompact})),new ae({keyBytes:e.bytesToSign(),signature:s})}}class oe extends ie{constructor(e){super({createdNs:e.timestamp.mul(1e6),secp256k1Uncompressed:e.secp256k1Uncompressed}),e.signature&&(!e.signature.ecdsaCompact&&e.signature.walletEcdsaCompact?this.signature=new te({ecdsaCompact:{bytes:e.signature.walletEcdsaCompact.bytes,recovery:e.signature.walletEcdsaCompact.recovery}}):this.signature=new te(e.signature))}get timestamp(){return this.createdNs.div(1e6)}bytesToSign(){return r.PublicKey.encode({timestamp:this.timestamp,secp256k1Uncompressed:this.secp256k1Uncompressed}).finish()}async signWithWallet(e){const t=await e.signMessage(re.identitySigRequestText(this.bytesToSign())),{bytes:s,recovery:r}=J(t);this.signature=new te({ecdsaCompact:{bytes:s,recovery:r}})}walletSignatureAddress(){if(!this.signature)throw new Error("key is not signed");const e=v(b(re.identitySigRequestText(this.bytesToSign()))),t=this.signature.getPublicKey(e);if(!t)throw new Error("key signature is malformed");return t.getEthereumAddress()}toBytes(){return r.PublicKey.encode(this).finish()}static fromBytes(e){return new oe(r.PublicKey.decode(e))}}class ce{constructor(e){if(!e.identityKey)throw new Error("missing identity key");if(!e.preKey)throw new Error("missing pre-key");this.identityKey=new ae(e.identityKey),this.preKey=new ae(e.preKey)}walletSignatureAddress(){return this.identityKey.walletSignatureAddress()}equals(e){return this.identityKey.equals(e.identityKey)&&this.preKey.equals(e.preKey)}toBytes(){return r.SignedPublicKeyBundle.encode(this).finish()}isFromLegacyBundle(){return this.identityKey.isFromLegacyKey()&&this.preKey.isFromLegacyKey()}toLegacyBundle(){return new de({identityKey:this.identityKey.toLegacyKey(),preKey:this.preKey.toLegacyKey()})}static fromBytes(e){const t=r.SignedPublicKeyBundle.decode(e);return new ce(t)}static fromLegacyBundle(e){return new ce({identityKey:ae.fromLegacyKey(e.identityKey,!0),preKey:ae.fromLegacyKey(e.preKey)})}}class de{constructor(e){if(!e.identityKey)throw new Error("missing identity key");if(!e.preKey)throw new Error("missing pre-key");this.identityKey=new oe(e.identityKey),this.preKey=new oe(e.preKey)}equals(e){return this.identityKey.equals(e.identityKey)&&this.preKey.equals(e.preKey)}walletSignatureAddress(){return this.identityKey.walletSignatureAddress()}toBytes(){return r.PublicKeyBundle.encode(this).finish()}static fromBytes(e){const t=r.PublicKeyBundle.decode(e);return new de(t)}}class he{constructor(e,t){this.messageEnvelope=e,this.onSend=t}async messageID(){if(!this.messageEnvelope.message)throw new Error("no envelope message");return j(await _(this.messageEnvelope.message))}async send(){return this.onSend()}}class ye{constructor(e,t,s,r,n){this.messages=[],this.resolvers=[],this.topics=t,this.client=e,this.callback=this.newMessageCallback(s,r),this.onConnectionLost=n}newMessageCallback(e,t){return async s=>{if(s.message)try{const r=await e(s);if(!r)return;if(t){const e=t(r);e&&this.resubscribeToTopics(e)}const n=this.resolvers.pop();n?n({value:r}):this.messages.unshift(r)}catch(e){console.warn(e)}}}async start(){if(!this.callback)throw new Error("Missing callback for stream");this.subscriptionManager=this.client.apiClient.subscribe({contentTopics:this.topics},(async e=>{this.callback&&await(this?.callback(e))}),this.onConnectionLost)}static async create(e,t,s,r,n){const i=new ye(e,t,s,r,n);return await i.start(),i}[Symbol.asyncIterator](){return this}async return(){return this.subscriptionManager&&await this.subscriptionManager.unsubscribe(),this.callback?(this.callback=void 0,this.resolvers.forEach((e=>e({value:void 0,done:!0}))),{value:void 0,done:!0}):{value:void 0,done:!0}}next(){const e=this.messages.pop();return e?Promise.resolve({value:e}):this.callback?new Promise((e=>this.resolvers.unshift(e))):Promise.resolve({value:void 0,done:!0})}async resubscribeToTopics(e){if(!this.callback||!this.subscriptionManager)throw new Error("Missing callback for stream");if("function"==typeof this.subscriptionManager?.updateContentTopics)return this.subscriptionManager.updateContentTopics(e);await this.subscriptionManager.unsubscribe(),this.topics=e,this.subscriptionManager=this.client.apiClient.subscribe({contentTopics:this.topics},(async e=>{this.callback&&await(this?.callback(e))}),this.onConnectionLost)}}const{b64Decode:ue,b64Encode:le}=n;function pe(e,t){const s=new Uint8Array(e.length+t.length);return s.set(e),s.set(t,e.length),s}function we(e){const t=new ArrayBuffer(4);return new DataView(t).setInt32(0,e,!0),new Uint8Array(t)}function fe(e){const t=e.buffer;return new DataView(t).getInt32(0,!0)}function me(e){return l.fromNumber(e.valueOf()).multiply(1e6)}function ge(e){return new Date(e.divide(1e6).toNumber())}const ve=e=>e&&me(e).toString(),be=e=>{if(e)return ge(l.fromString(e))};class Ee extends Error{constructor(e,t){super(t),this.code=e}}const Ke=e=>{if(e.error)throw new Ee(e.error.code,e.error.message);if(!e.result)throw new Ee(i.ErrorCode.ERROR_CODE_UNSPECIFIED,"No result from Keystore");if("encrypted"in e.result&&!e.result.encrypted)throw new Error("Missing ciphertext");if("decrypted"in e.result&&!e.result.decrypted)throw new Error("Missing decrypted result");return e.result},ke=(e,t)=>({requests:e.map((e=>{const s=new de({identityKey:e.header.sender?.identityKey,preKey:e.header.sender?.preKey}),r=t.equals(s);return{payload:e.ciphertext,peerKeys:r?new de({identityKey:e.header.recipient?.identityKey,preKey:e.header.recipient?.preKey}):s,headerBytes:e.headerBytes,isSender:r}}))}),Pe=e=>`/xmtp/0/${e}/proto`,Se=(e,t)=>{const s=[m(e),m(t)];return s.sort(),Pe(`dm-${s.join("-")}`)},Ae=e=>Pe(`m-${e}`),Te=e=>Pe(`contact-${m(e)}`),Ce=e=>Pe(`intro-${m(e)}`),Ie=e=>Pe(`invite-${m(e)}`),Be=e=>Pe(`privatestore-${e}`),Re=e=>{const t=/^[\x21-\x7F]+$/,s=e.indexOf("0/");if(-1!==s){const r=e.substring(s+2,e.lastIndexOf("/proto"));return t.test(r)}return!1};class Ne{constructor(e,t,s){this.conversationVersion="v1",this.context=void 0,this.peerAddress=m(t),this.client=e,this.createdAt=s}get clientAddress(){return this.client.address}async allow(){await this.client.contacts.allow([this.peerAddress])}async deny(){await this.client.contacts.deny([this.peerAddress])}get isAllowed(){return this.client.contacts.isAllowed(this.peerAddress)}get isDenied(){return this.client.contacts.isDenied(this.peerAddress)}get consentState(){return this.client.contacts.consentState(this.peerAddress)}get topic(){return Se(this.peerAddress,this.client.address)}get ephemeralTopic(){return Se(this.peerAddress,this.client.address).replace("/xmtp/0/dm-","/xmtp/0/dmE-")}async messages(e){const t=Se(this.peerAddress,this.client.address),s=await this.client.listEnvelopes(t,this.processEnvelope.bind(this),e);return this.decryptBatch(s,t,!1)}messagesPaginated(e){return this.client.listEnvelopesPaginated(this.topic,this.decodeMessage.bind(this),e)}async decodeMessage(e){if(!e.contentTopic)throw new Error("Missing content topic");const t=await this.processEnvelope(e),s=await this.decryptBatch([t],e.contentTopic,!0);if(!s.length)throw new Error("No results");return s[0]}async prepareMessage(e,t){let s,r=await this.client.getUserContact(this.peerAddress);if(!r)throw new Error(`recipient ${this.peerAddress} is not registered`);r instanceof de||(r=r.toLegacyBundle());const n=t?.ephemeral?this.ephemeralTopic:this.topic;this.client.contacts.addresses.has(this.peerAddress)?s=[n]:(s=[Ce(this.peerAddress),Ce(this.client.address),n],this.client.contacts.addresses.add(this.peerAddress));const{payload:i}=await this.client.encodeContent(e,t),a=await this.createMessage(i,r,t?.timestamp),o=a.toBytes(),c={contentTopic:n,message:o,timestampNs:ve(a.sent)};return new he(c,(async()=>(await this.client.publishEnvelopes(s.map((e=>({contentTopic:e,message:o,timestamp:a.sent})))),Ue.fromV1Message(a,e,t?.contentType||K,i,n,this))))}streamMessages(e){return ye.create(this.client,[this.topic],(async e=>this.decodeMessage(e)),void 0,e)}async processEnvelope({message:e,contentTopic:t}){if(!e||!e.length)throw new Error("empty envelope");const s=await _e.fromBytes(e),{senderAddress:r,recipientAddress:n}=s;if(!r||!n||!t||Se(r,n)!==this.topic)throw new Error("Headers do not match intended recipient");return s}streamEphemeral(e){return ye.create(this.client,[this.ephemeralTopic],this.decodeMessage.bind(this),void 0,e)}async send(e,t){let s,r=await this.client.getUserContact(this.peerAddress);if(!r)throw new Error(`recipient ${this.peerAddress} is not registered`);r instanceof de||(r=r.toLegacyBundle());const n=t?.ephemeral?this.ephemeralTopic:this.topic;this.client.contacts.addresses.has(this.peerAddress)?s=[n]:(s=[Ce(this.peerAddress),Ce(this.client.address),n],this.client.contacts.addresses.add(this.peerAddress));const i=t?.contentType||K,{payload:a}=await this.client.encodeContent(e,t),o=await this.createMessage(a,r,t?.timestamp);return await this.client.publishEnvelopes(s.map((e=>({contentTopic:e,message:o.toBytes(),timestamp:o.sent})))),"unknown"===this.consentState&&await this.allow(),Ue.fromV1Message(o,e,i,a,n,this)}async decryptBatch(e,t,s=!1){const r=(await this.client.keystore.decryptV1(ke(e,this.client.publicKeyBundle))).responses,n=[];for(let i=0;i<r.length;i++){const a=r[i],o=e[i];try{const{decrypted:e}=Ke(a);n.push(await this.buildDecodedMessage(o,e,t))}catch(e){if(s)throw e;console.warn("Error decoding content",e)}}return n}async buildDecodedMessage(e,t,s){const{content:r,contentType:n,error:i,contentFallback:a}=await this.client.decodeContent(t);return Ue.fromV1Message(e,r,n,t,s,this,i,a)}async createMessage(e,t,s){return s=s||new Date,_e.encode(this.client.keystore,e,this.client.publicKeyBundle,t,s)}}class De{constructor(e,t,s,r,n,i){this.conversationVersion="v2",this.topic=t,this.createdAt=r,this.context=n,this.client=e,this.peerAddress=s,this.consentProof=i}get clientAddress(){return this.client.address}async allow(){await this.client.contacts.allow([this.peerAddress])}async deny(){await this.client.contacts.deny([this.peerAddress])}get isAllowed(){return this.client.contacts.isAllowed(this.peerAddress)}get isDenied(){return this.client.contacts.isDenied(this.peerAddress)}get consentState(){return this.client.contacts.consentState(this.peerAddress)}get consentProofPayload(){return this.consentProof}async messages(e){const t=await this.client.listEnvelopes(this.topic,this.processEnvelope.bind(this),e);return this.decryptBatch(t,!1)}messagesPaginated(e){return this.client.listEnvelopesPaginated(this.topic,this.decodeMessage.bind(this),e)}get ephemeralTopic(){return this.topic.replace("/xmtp/0/m","/xmtp/0/mE")}streamEphemeral(e){return ye.create(this.client,[this.ephemeralTopic],this.decodeMessage.bind(this),void 0,e)}streamMessages(e){return ye.create(this.client,[this.topic],this.decodeMessage.bind(this),void 0,e)}async send(e,t){const{payload:s,shouldPush:r}=await this.client.encodeContent(e,t),n=await this.createMessage(s,r,t?.timestamp),i=t?.ephemeral?this.ephemeralTopic:this.topic;await this.client.publishEnvelopes([{contentTopic:i,message:n.toBytes(),timestamp:n.sent}]);const a=t?.contentType||K;return"unknown"===this.consentState&&await this.allow(),Ue.fromV2Message(n,e,a,i,s,this,this.client.address)}async createMessage(e,t,s){const r={topic:this.topic,createdNs:me(s||new Date)},n=a.MessageHeaderV2.encode(r).finish(),i=await _(pe(n,e)),c={payload:e,sender:this.client.signedPublicKeyBundle,signature:await this.client.keystore.signDigest({digest:i,prekeyIndex:0,identityKey:void 0})},d=o.SignedContent.encode(c).finish(),{encrypted:h,senderHmac:y}=await this.encryptMessage(d,n),u={v1:void 0,v2:{headerBytes:n,ciphertext:h,senderHmac:y,shouldPush:t}},l=a.Message.encode(u).finish();return Ve.create(u,r,l,y,t)}async decryptBatch(e,t=!1){const s=(await this.client.keystore.decryptV2(this.buildDecryptRequest(e))).responses,r=[];for(let n=0;n<s.length;n++){const i=s[n],a=e[n];try{const{decrypted:e}=Ke(i);r.push(await this.buildDecodedMessage(a,e))}catch(e){if(t)throw e;console.warn("Error decoding content",e)}}return r}buildDecryptRequest(e){return{requests:e.map((e=>({payload:e.ciphertext,headerBytes:e.headerBytes,contentTopic:this.topic})))}}async encryptMessage(e,t){const{responses:s}=await this.client.keystore.encryptV2({requests:[{payload:e,headerBytes:t,contentTopic:this.topic}]});if(1!==s.length)throw new Error("Invalid response length");const{encrypted:r,senderHmac:n}=Ke(s[0]);return{encrypted:r,senderHmac:n}}async buildDecodedMessage(e,t){const s=o.SignedContent.decode(t);if(!s.sender?.identityKey||!s.sender?.preKey||!s.signature)throw new Error("incomplete signed content");await async function(e){const t=e.sender?.preKey;if(!t||!t.signature||!t.keyBytes)throw new Error("missing pre-key or pre-key signature");const s=e.sender?.identityKey;if(!s)throw new Error("missing identity key in bundle");if(!await new ae(s).verifyKey(new ae(t)))throw new Error("pre key not signed by identity key")}(s);const r=await _(pe(e.headerBytes,s.payload));if(!new ae(s.sender?.preKey).verify(new te(s.signature),r))throw new Error("invalid signature");const n=await new ce(s.sender).walletSignatureAddress(),{content:i,contentType:a,error:c,contentFallback:d}=await this.client.decodeContent(s.payload);return Ue.fromV2Message(e,i,a,this.topic,s.payload,this,n,c,d)}async prepareMessage(e,t){const{payload:s,shouldPush:r}=await this.client.encodeContent(e,t),n=await this.createMessage(s,r,t?.timestamp),i=n.toBytes(),a=t?.ephemeral?this.ephemeralTopic:this.topic,o={contentTopic:a,message:i,timestampNs:ve(n.sent)};return new he(o,(async()=>(await this.client.publishEnvelopes([{contentTopic:a,message:i,timestamp:n.sent}]),Ue.fromV2Message(n,e,t?.contentType||K,a,s,this,this.client.address))))}async processEnvelope(e){if(!e.message||!e.contentTopic)throw new Error("empty envelope");const t=a.Message.decode(e.message);if(!t.v2)throw new Error("unknown message version");const s=a.MessageHeaderV2.decode(t.v2.headerBytes);if(s.topic!==this.topic)throw new Error("topic mismatch");return Ve.create(t,s,e.message,t.v2.senderHmac,t.v2.shouldPush)}async decodeMessage(e){if(!e.contentTopic)throw new Error("Missing content topic");const t=await this.processEnvelope(e),s=await this.decryptBatch([t],!0);if(!s.length)throw new Error("No results");return s[0]}}const Me=e=>{if(e.v1?.ciphertext)return[e.v1.headerBytes,new N(e.v1.ciphertext)];if(e.v2?.ciphertext)return[e.v2.headerBytes,new N(e.v2.ciphertext)];throw new Error("unknown message version")};class xe{constructor(e,t,s){[this.headerBytes,this.ciphertext]=Me(s),this.id=e,this.bytes=t}toBytes(){return this.bytes}}class _e extends xe{constructor(e,t,s,r,n){super(e,t,s),this.conversation=void 0,this.senderAddress=n,this.header=r}static async create(e,t,s){if(!t.sender)throw new Error("missing message sender");const r=new de(t.sender).walletSignatureAddress(),n=j(await _(s));return new _e(n,s,e,t,r)}get sent(){return new Date(this.header.timestamp.toNumber())}get recipientAddress(){if(this.header?.recipient?.identityKey)return new oe(this.header.recipient.identityKey).walletSignatureAddress()}async decrypt(e,t){const s=(await e.decryptV1(ke([this],t))).responses;if(!s.length)throw new Error("No response from Keystore");const{decrypted:r}=Ke(s[0]);return r}static fromBytes(e){const t=a.Message.decode(e),[s]=Me(t),r=a.MessageHeaderV1.decode(s);if(!r)throw new Error("missing message header");if(!r.sender)throw new Error("missing message sender");if(!r.sender.identityKey)throw new Error("missing message sender identity key");if(!r.sender.preKey)throw new Error("missing message sender pre-key");if(!r.recipient)throw new Error("missing message recipient");if(!r.recipient.identityKey)throw new Error("missing message recipient identity-key");if(!r.recipient.preKey)throw new Error("missing message recipient pre-key");return _e.create(t,r,e)}static async encode(e,t,s,r,n){const i={sender:s,recipient:r,timestamp:l.fromNumber(n.getTime())},o=a.MessageHeaderV1.encode(i).finish(),c=await e.encryptV1({requests:[{recipient:r,headerBytes:o,payload:t}]});if(!c.responses.length)throw new Error("No response from Keystore");const{encrypted:d}=Ke(c.responses[0]),h={v1:{headerBytes:o,ciphertext:d},v2:void 0},y=a.Message.encode(h).finish();return _e.create(h,i,y)}}class Ve extends xe{constructor(e,t,s,r,n,i){super(e,t,s),this.header=r,this.senderHmac=n,this.shouldPush=i}static async create(e,t,s,r,n){const i=j(await _(s));return new Ve(i,s,e,t,r,n)}get sent(){return ge(this.header.createdNs)}}class Ue{constructor({id:e,messageVersion:t,senderAddress:s,recipientAddress:r,conversation:n,contentBytes:i,contentType:a,contentTopic:o,content:c,sent:d,error:h,contentFallback:y}){this.id=e,this.messageVersion=t,this.senderAddress=s,this.recipientAddress=r,this.conversation=n,this.contentType=a,this.sent=d,this.error=h,this.content=c,this.contentTopic=o,this.contentBytes=i,this.contentFallback=y}toBytes(){return a.DecodedMessage.encode({...this,conversation:{topic:this.conversation.topic,context:this.conversation.context??void 0,createdNs:me(this.conversation.createdAt),peerAddress:this.conversation.peerAddress,consentProofPayload:this.conversation.consentProof??void 0},sentNs:me(this.sent)}).finish()}static async fromBytes(e,t){const s=a.DecodedMessage.decode(e),r=s.messageVersion;if("v1"!==r&&"v2"!==r)throw new Error("Invalid message version");if(!s.conversation)throw new Error("No conversation reference found");const{content:n,contentType:i,error:o,contentFallback:c}=await t.decodeContent(s.contentBytes);return new Ue({...s,content:n,contentType:i,error:o,messageVersion:r,sent:ge(s.sentNs),conversation:Oe(s.conversation,t,r),contentFallback:c})}static fromV1Message(e,t,s,r,n,i,a,o){const{id:c,senderAddress:d,recipientAddress:h,sent:y}=e;if(!d)throw new Error("Sender address is required");return new Ue({id:c,messageVersion:"v1",senderAddress:d,recipientAddress:h,sent:y,content:t,contentBytes:r,contentType:s,contentTopic:n,conversation:i,error:a,contentFallback:o})}static fromV2Message(e,t,s,r,n,i,a,o,c){const{id:d,sent:h}=e;return new Ue({id:d,messageVersion:"v2",senderAddress:a,sent:h,content:t,contentBytes:n,contentType:s,contentTopic:r,conversation:i,error:o,contentFallback:c})}}function Oe(e,t,s){if("v1"===s)return new Ne(t,e.peerAddress,ge(e.createdNs));if("v2"===s)return new De(t,e.topic,e.peerAddress,ge(e.createdNs),e.context,e.consentProofPayload);throw new Error(`Unknown conversation version ${s}`)}function qe(e,t){return t.decodeContent(e)}class Le extends Error{constructor(e){super(`no pre-key matches: ${j(e.secp256k1Uncompressed.bytes)}`)}}class Ge{constructor(e){if(this.version=2,!e.identityKey)throw new Error("missing identity key");this.identityKey=new W(e.identityKey),this.preKeys=(e.preKeys||[]).map((e=>new W(e)))}static async generate(e){const t=await W.generate(new re(e)),s=new Ge({identityKey:t,preKeys:[]});return await s.addPreKey(),s}getCurrentPreKey(){return this.preKeys[0]}findPreKey(e){const t=this.preKeys.find((t=>t.matches(e)));if(!t)throw new Le(e);return t}async addPreKey(){this._publicKeyBundle=void 0;const e=await W.generate(this.identityKey);this.preKeys.unshift(e)}getPublicKeyBundle(){return this._publicKeyBundle||(this._publicKeyBundle=new ce({identityKey:this.identityKey.publicKey,preKey:this.getCurrentPreKey().publicKey})),this._publicKeyBundle}async sharedSecret(e,t,s){if(!e.identityKey||!e.preKey)throw new Error("invalid peer key bundle");if(!await e.identityKey.verifyKey(e.preKey))throw new Error("peer preKey signature invalid");if(!this.identityKey)throw new Error("missing identity key");let r,n,i;s?(i=this.findPreKey(t),r=i.sharedSecret(e.identityKey),n=this.identityKey.sharedSecret(e.preKey)):(i=this.findPreKey(t),r=this.identityKey.sharedSecret(e.preKey),n=i.sharedSecret(e.identityKey));const a=i.sharedSecret(e.preKey),o=new Uint8Array(r.length+n.length+a.length);return o.set(r,0),o.set(n,r.length),o.set(a,r.length+n.length),o}encode(){return t.PrivateKeyBundle.encode({v1:void 0,v2:this}).finish()}validatePublicKeys(){return!!this.identityKey.validatePublicKey()&&this.preKeys.every((e=>e.validatePublicKey()))}equals(e){if(this.preKeys.length!==e.preKeys.length)return!1;for(let t=0;t<this.preKeys.length;t++)if(!this.preKeys[t].equals(e.preKeys[t]))return!1;return this.identityKey.equals(e.identityKey)}static fromLegacyBundle(e){return new Ge({identityKey:W.fromLegacyKey(e.identityKey,!0),preKeys:e.preKeys.map((e=>W.fromLegacyKey(e)))})}}class He{constructor(e){if(this.version=1,!e.identityKey)throw new Error("missing identity key");this.identityKey=new Y(e.identityKey),this.preKeys=(e.preKeys||[]).map((e=>new Y(e)))}static async generate(e){const t=Y.generate();e&&await t.publicKey.signWithWallet(e);const s=new He({identityKey:t,preKeys:[]});return await s.addPreKey(),s}getCurrentPreKey(){return this.preKeys[0]}findPreKey(e){const t=this.preKeys.find((t=>t.matches(e)));if(!t)throw new Le(e);return t}async addPreKey(){this._publicKeyBundle=void 0;const e=Y.generate();await this.identityKey.signKey(e.publicKey),this.preKeys.unshift(e)}getPublicKeyBundle(){return this._publicKeyBundle||(this._publicKeyBundle=new de({identityKey:this.identityKey.publicKey,preKey:this.getCurrentPreKey().publicKey})),this._publicKeyBundle}validatePublicKeys(){return!!this.identityKey.validatePublicKey()&&this.preKeys.every((e=>e.validatePublicKey()))}async sharedSecret(e,t,s){if(!e.identityKey||!e.preKey)throw new Error("invalid peer key bundle");if(!await e.identityKey.verifyKey(e.preKey))throw new Error("peer preKey signature invalid");if(!this.identityKey)throw new Error("missing identity key");let r,n,i;s?(i=this.findPreKey(t),r=i.sharedSecret(e.identityKey),n=this.identityKey.sharedSecret(e.preKey)):(i=this.findPreKey(t),r=this.identityKey.sharedSecret(e.preKey),n=i.sharedSecret(e.identityKey));const a=i.sharedSecret(e.preKey),o=new Uint8Array(r.length+n.length+a.length);return o.set(r,0),o.set(n,r.length),o.set(a,r.length+n.length),o}encode(){return t.PrivateKeyBundle.encode({v1:this,v2:void 0}).finish()}}function Fe(e){const s=t.PrivateKeyBundle.decode(e);if(s.v1)return new He(s.v1);if(s.v2)return new Ge(s.v2);throw new Error("unknown private key bundle version")}class $e{constructor({walletAddr:e,createdNs:t}){this.walletAddr=e,this.createdNs=t}static create(e,t){return t=t||new Date,new $e({walletAddr:e,createdNs:me(t)})}static fromBytes(e){const t=c.AuthData.decode(e);return new $e(t)}toBytes(){return c.AuthData.encode(this).finish()}}class je{constructor({identityKey:e,authDataBytes:t,authDataSignature:s}){if(!e)throw new Error("Missing identity key in token");if(!s)throw new Error("Missing authDataSignature in token");this.identityKey=e,this.authDataBytes=t,this.authDataSignature=s}get authData(){return this._authData||(this._authData=$e.fromBytes(this.authDataBytes)),this._authData}get ageMs(){return(new Date).valueOf()-this.authData.createdNs.div(1e6).toNumber()}toBytes(){return c.Token.encode(this).finish()}static fromBytes(e){return new je(c.Token.decode(e))}toBase64(){return Buffer.from(this.toBytes()).toString("base64")}}class Xe{constructor(e){this.keystore=e}async createToken(e){return(e=>e instanceof je?e:new je(e))(await this.keystore.createAuthToken({timestampNs:e?me(e):void 0}))}}const Je=e=>new Promise((t=>setTimeout(t,e))),ze=e=>!!e;async function We(e,t,s,r,n=ze,i=1){const a="number"==typeof i?i:1;try{return await e(...t)}catch(i){if(!n(i)||a>s)throw i;return await Je(r),We(e,t,s,r,n,a+1)}}async function*Ye(e,t){for await(const s of e){const e=await Promise.allSettled(s.map(t)),r=[];for(const t of e)"fulfilled"===t.status?r.push(t.value):console.warn("Failed to process envelope due to reason: ",t.reason);yield r}}class Qe{constructor(e,t=3590){this.authenticator=e,this.maxAgeMs=1e3*t}async getToken(){return(!this.token||this.token.ageMs>this.maxAgeMs)&&await this.refresh(),this.token.toBase64()}async refresh(){this.token=await this.authenticator.createToken()}}const{MessageApi:Ze,SortDirection:et}=d,tt={local:"http://localhost:5555",dev:"https://dev.xmtp.network",production:"https://production.xmtp.network"};var st;!function(e){e[e.OK=0]="OK",e[e.CANCELLED=1]="CANCELLED",e[e.UNKNOWN=2]="UNKNOWN",e[e.INVALID_ARGUMENT=3]="INVALID_ARGUMENT",e[e.DEADLINE_EXCEEDED=4]="DEADLINE_EXCEEDED",e[e.NOT_FOUND=5]="NOT_FOUND",e[e.ALREADY_EXISTS=6]="ALREADY_EXISTS",e[e.PERMISSION_DENIED=7]="PERMISSION_DENIED",e[e.RESOURCE_EXHAUSTED=8]="RESOURCE_EXHAUSTED",e[e.FAILED_PRECONDITION=9]="FAILED_PRECONDITION",e[e.ABORTED=10]="ABORTED",e[e.OUT_OF_RANGE=11]="OUT_OF_RANGE",e[e.UNIMPLEMENTED=12]="UNIMPLEMENTED",e[e.INTERNAL=13]="INTERNAL",e[e.UNAVAILABLE=14]="UNAVAILABLE",e[e.DATA_LOSS=15]="DATA_LOSS",e[e.UNAUTHENTICATED=16]="UNAUTHENTICATED"}(st||(st={}));class rt extends Error{constructor(e,t){super(e),this.code=t}static fromObject(e){return new rt(e.message,e.code)}}const nt=e=>!!e&&!("AbortError"!==e.name&&!e.message.includes("aborted")),it=e=>!(e=>!(!e||!("code"in e)||16!==e.code))(e),at=e=>e.message&&e.message.length?("string"==typeof e.message&&(e.message=ue(e.message)),e):e;class ot{constructor(e,t){this.pathPrefix=e,this.maxRetries=t?.maxRetries||5,this.appVersion=t?.appVersion,this.version="xmtp-js/13.0.3",e===tt.dev&&console.info("\nXX    XX MM    MM TTTTTT PPPPPP   DDDDD   EEEEEEE VV     VV \n XX  XX  MMM  MMM   TT   PP   PP  DD  DD  EE      VV     VV \n  XXXX   MM MM MM   TT   PPPPPP   DD   DD EEEEE    VV   VV  \n XX  XX  MM    MM   TT   PP       DD   DD EE        VV VV   \nXX    XX MM    MM   TT   PP       DDDDDD  EEEEEEE    VVV    \n\nConnected to the XMTP 'dev' network. Use 'production' for production messages.\nhttps://github.com/xmtp/xmtp-js#xmtp-production-and-dev-network-environments\n")}async _query(e){try{return await We(Ze.Query,[e,{pathPrefix:this.pathPrefix,mode:"cors",headers:this.headers()}],this.maxRetries,100)}catch(e){throw rt.fromObject(e)}}_batchQuery(e){return We(Ze.BatchQuery,[e,{pathPrefix:this.pathPrefix,mode:"cors",headers:this.headers()}],this.maxRetries,100)}async _publish(e,t=0){const s=await this.getToken(),r=this.headers();r.set("Authorization",`Bearer ${s}`);try{return await We(Ze.Publish,[e,{pathPrefix:this.pathPrefix,mode:"cors",headers:r}],this.maxRetries,100,it)}catch(s){if(it(s)||t>=1)throw rt.fromObject(s);return await(this.authCache?.refresh()),this._publish(e,t+1)}}_subscribe(e,t,s){const r=new AbortController;return(async()=>{for(;;){const n=(new Date).getTime();try{if(await Ze.Subscribe(e,t,{pathPrefix:this.pathPrefix,signal:r.signal,mode:"cors",headers:this.headers()}),r.signal.aborted)return;console.info("Stream connection closed. Resubscribing"),(new Date).getTime()-n<1e3&&await Je(1e3),s?.()}catch(e){if(nt(e)||r.signal.aborted)return;console.info("Stream connection closed. Resubscribing"),(new Date).getTime()-n<1e3&&await Je(1e3),s?.()}}})(),{unsubscribe:async()=>{r?.abort()}}}async query(e,{direction:t=et.SORT_DIRECTION_ASCENDING,limit:s,pageSize:r}){const n=[],i=e.contentTopic.startsWith("userpreferences-")?500:100;for await(const a of this.queryIteratePages(e,{direction:t,pageSize:r?Math.min(r,i):i}))for(const e of a)if(n.push(e),s&&n.length===s)return n;return n}async*queryIterator(e,t){for await(const s of this.queryIteratePages(e,t))for(const e of s)yield e}async*queryIteratePages({contentTopic:e,startTime:t,endTime:s},{direction:r,pageSize:n=10}){if(!e||!e.length)throw new Error("Must specify content topics");const i=ve(t),a=ve(s);let o;for(;;){const t={limit:n,direction:r,cursor:o},s=await this._query({contentTopics:[e],startTimeNs:i,endTimeNs:a,pagingInfo:t});if(!s.envelopes?.length)return;if(yield s.envelopes.map(at),!s.pagingInfo?.cursor)return;o=s.pagingInfo?.cursor}}async batchQuery(e){const t=[];for(let s=0;s<e.length;s+=50){const r=e.slice(s,s+50),n=[];for(const e of r)n.push({contentTopics:[e.contentTopic],startTimeNs:ve(e.startTime),endTimeNs:ve(e.endTime),pagingInfo:{limit:e.pageSize||10,direction:e.direction||et.SORT_DIRECTION_ASCENDING}});const i={requests:n};t.push(i)}const s=await Promise.all(t.map((async e=>this._batchQuery(e)))),r=[];for(const e of s){if(!e.responses)throw new Error("BatchQueryResponse missing responses");for(const t of e.responses)t.envelopes?r.push(t.envelopes.map(at)):r.push([])}return r}async publish(e){const t=[];for(const{contentTopic:s,message:r,timestamp:n}of e){if(!s.length)throw new Error("Content topic cannot be empty string");if(!r.length)throw new Error("0 length messages not allowed");const e=n||new Date;t.push({contentTopic:s,timestampNs:ve(e),message:Uint8Array.from(r)})}return this._publish({envelopes:t})}subscribe(e,t,s){if(!e.contentTopics.length)throw new Error("Must provide list of contentTopics to subscribe to");return this._subscribe(e,(e=>t(at(e))),s)}getToken(){if(!this.authCache)throw new Error("AuthCache is not set on API Client");return this.authCache.getToken()}setAuthenticator(e,t){this.authCache=new Qe(e,t)}headers(){const e=new Headers;return e.set("X-Client-Version",this.version),this.appVersion&&e.set("X-App-Version",this.appVersion),e}}class ct{constructor(e,t){this.disableOffset=!1,this.jobType=e,this.mutex=new S,this.keystore=t}get protoJobType(){return function(e){const t={v1:i.JobType.JOB_TYPE_REFRESH_V1,v2:i.JobType.JOB_TYPE_REFRESH_V2,"user-preferences":i.JobType.JOB_TYPE_REFRESH_PPPP}[e];if(!t)throw new Error(`unknown job type: ${e}`);return t}(this.jobType)}async run(e){return this.mutex.runExclusive((async()=>{const t=await this.getLastRunTime(),s=new Date,r=await e(t?this.disableOffset?t:new Date(t.getTime()-1e4):void 0);return await this.setLastRunTime(s),r}))}async resetLastRunTime(){await this.keystore.setRefreshJob({jobType:this.protoJobType,lastRunNs:me(new Date(0))})}async getLastRunTime(){const{lastRunNs:e}=await this.keystore.getRefreshJob(i.GetRefreshJobRequest.fromPartial({jobType:this.protoJobType}));if(!e.equals(l.fromNumber(0)))return ge(e)}async setLastRunTime(e){await this.keystore.setRefreshJob({jobType:this.protoJobType,lastRunNs:me(e)})}}const dt=e=>Boolean(e.recipientAddress&&e.senderAddress);class ht{constructor(e){this.client=e,this.v1JobRunner=new ct("v1",e.keystore),this.v2JobRunner=new ct("v2",e.keystore)}async list(){const[e,t]=await Promise.all([this.listV1Conversations(),this.listV2Conversations()]),s=e.concat(t);return s.sort(((e,t)=>e.createdAt.getTime()-t.createdAt.getTime())),s}async listFromCache(){const[e,t]=await Promise.all([this.getV1ConversationsFromKeystore(),this.getV2ConversationsFromKeystore()]),s=e.concat(t);return s.sort(((e,t)=>e.createdAt.getTime()-t.createdAt.getTime())),s}async listV1Conversations(){return this.v1JobRunner.run((async e=>{const t=await this.getIntroductionPeers({startTime:e,direction:et.SORT_DIRECTION_ASCENDING});return await this.client.keystore.saveV1Conversations({conversations:Array.from(t).map((([e,t])=>({peerAddress:e,createdNs:me(t),topic:Se(e,this.client.address),context:void 0,consentProofPayload:void 0}))).filter((e=>Re(e.topic)))}),(await this.client.keystore.getV1Conversations()).conversations.map(this.conversationReferenceToV1.bind(this))}))}async listV2Conversations(){return this.v2JobRunner.run((async e=>{const t=await this.getV2ConversationsFromKeystore(),s=await this.updateV2Conversations(e),r=new Set(t.map((e=>e.topic)));for(const e of s)r.has(e.topic)||(t.push(e),r.add(e.topic));return t.sort(((e,t)=>e.createdAt.getTime()-t.createdAt.getTime())),t}))}async getV2ConversationsFromKeystore(){return(await this.client.keystore.getV2Conversations()).conversations.map(this.conversationReferenceToV2.bind(this))}async getV1ConversationsFromKeystore(){return(await this.client.keystore.getV1Conversations()).conversations.map(this.conversationReferenceToV1.bind(this))}async updateV2Conversations(e){const t=await this.client.listInvitations({startTime:e,direction:et.SORT_DIRECTION_ASCENDING});return this.decodeInvites(t)}async decodeInvites(e,t=!1){const{responses:s}=await this.client.keystore.saveInvites({requests:e.map((e=>({payload:e.message,timestampNs:l.fromString(e.timestampNs),contentTopic:e.contentTopic}))).filter((e=>Re(e.contentTopic)))}),r=[];for(const e of s)try{r.push(this.saveInviteResponseToConversation(e))}catch(e){if(console.warn("Error saving invite response to conversation: ",e),t)throw e}return r}saveInviteResponseToConversation({result:e,error:t}){if(t||!e||!e.conversation)throw new Error(`Error from keystore: ${t?.code} ${t?.message}}`);return this.conversationReferenceToV2(e.conversation)}conversationReferenceToV2(e){return new De(this.client,e.topic,e.peerAddress,ge(e.createdNs),e.context,e.consentProofPayload)}conversationReferenceToV1(e){return new Ne(this.client,e.peerAddress,ge(e.createdNs))}async stream(e){const t=new Set,s=Ce(this.client.address),r=Ie(this.client.address),n=[s,r];return ye.create(this.client,n,(async e=>{if(e.contentTopic===s){if(!e.message)throw new Error("empty envelope");const s=await _e.fromBytes(e.message),r=this.getPeerAddress(s);if(!(e=>!t.has(e)&&(t.add(e),!0))(r))return;return await s.decrypt(this.client.keystore,this.client.publicKeyBundle),new Ne(this.client,r,s.sent)}if(e.contentTopic===r){const t=await this.decodeInvites([e],!0);if(t.length)return t[0]}throw new Error("unrecognized invite topic")}).bind(this),void 0,e)}async streamAllMessages(e){const t=Ce(this.client.address),s=Ie(this.client.address),r=new Set([t,s]),n=new Map;for(const e of await this.list())r.add(e.topic),n.set(e.topic,e);const i=(e,t)=>!r.has(e)&&(n.set(e,t),r.add(e),!0),a=await ye.create(this.client,Array.from(r.values()),(async e=>{const r=e.contentTopic;if(!r||!e.message)return null;if(r===t){const t=await _e.fromBytes(e.message);if(!dt(t))return null;const s=this.getPeerAddress(t);return new Ne(this.client,s,t.sent).decodeMessage(e)}if(r===s){return(await this.decodeInvites([e],!0))[0]}const i=n.get(r);if(i instanceof Ne)return i.decodeMessage(e);if(i instanceof De)return i.decodeMessage(e);throw console.log("Unknown topic"),new Error("Unknown topic")}),(e=>{if(e instanceof Ue&&e.contentTopic===t){const t=new Ne(this.client,e.recipientAddress?.toLowerCase()===this.client.address.toLowerCase()?e.senderAddress:e.recipientAddress,e.sent);return i(t.topic,t)?Array.from(r.values()):void 0}if(e instanceof De){return i(e.topic,e)?Array.from(r.values()):void 0}}),e),o=async function*(){for await(const e of a)if(e instanceof Ue&&(yield e),e instanceof De)for(const t of await e.messages())yield t}();return o.return=async()=>(await(a?.return()),{value:void 0,done:!0}),o}async getIntroductionPeers(e){const t=Ce(this.client.address),s=await this.client.listEnvelopes(t,(e=>{if(!e.message)throw new Error("empty envelope");return _e.fromBytes(e.message)}),e),r=new Map;for(const e of s){if(!dt(e))continue;const t=this.getPeerAddress(e);if(t){const s=r.get(t);if(!s||s>e.sent)try{await e.decrypt(this.client.keystore,this.client.publicKeyBundle),r.set(t,e.sent)}catch(e){continue}}}return r}async newConversation(e,t,s){const r=s=>{return s.peerAddress.toLowerCase()===e.toLowerCase()&&(r=t,n=s.context??void 0,r?.conversationId===n?.conversationId);var r,n},n=(await this.getV2ConversationsFromKeystore()).find(r);if(n)return n;let i=await this.client.getUserContact(e);if(!i)throw new Error(`Recipient ${e} is not on the XMTP network`);if(e.toLowerCase()===this.client.address.toLowerCase())throw new Error("self messaging not supported");if(i instanceof de&&!t?.conversationId)return new Ne(this.client,e,new Date);if(!t?.conversationId){const t=(await this.listV1Conversations()).find((t=>t.peerAddress.toLowerCase()===e.toLowerCase()));if(t){if(!this.client.signedPublicKeyBundle.isFromLegacyBundle())throw new Error("cannot resume pre-existing V1 conversation; client keys not compatible");if(!(i instanceof de||i.isFromLegacyBundle()))throw new Error("cannot resume pre-existing V1 conversation; peer keys not compatible");return t}}return i instanceof de&&(i=ce.fromLegacyBundle(i)),this.v2JobRunner.run((async e=>{const n=(await this.updateV2Conversations(e)).find(r);return n||this.createV2Convo(i,t,s)}))}async createV2Convo(e,t,s){const r=new Date,{payload:n,conversation:i}=await this.client.keystore.createInvite({recipient:e,context:t,createdNs:me(r),consentProof:s});if(!n||!i)throw new Error("Required field not returned from Keystore");const a=await e.walletSignatureAddress();return await this.client.publishEnvelopes([{contentTopic:Ie(a),message:n,timestamp:r},{contentTopic:Ie(this.client.address),message:n,timestamp:r}]),await this.client.contacts.allow([a]),this.conversationReferenceToV2(i)}getPeerAddress(e){return e.recipientAddress?.toLowerCase()===this.client.address.toLowerCase()?e.senderAddress:e.recipientAddress}}class yt{constructor(e){this.storage=e}static create(){if("undefined"==typeof localStorage)throw new Error("Missing LocalStorage. Use ephemeralPersistence instead");return new yt(localStorage)}async getItem(e){const t=this.storage.getItem(e);return null===t?null:Uint8Array.from(Buffer.from(t,"binary"))}async setItem(e,t){this.storage.setItem(e,Buffer.from(t).toString("binary"))}}class ut{constructor(){this.store=new Map}get length(){return this.store.size}clear(){this.store=new Map}getItem(e){return this.validateString(e),this.store.has(e)?String(this.store.get(e)):null}key(e){if(void 0===e)throw new TypeError("Failed to execute 'key' on 'Storage': 1 argument required, but only 0 present.");const t=[...this.store.keys()];return e>=t.length?null:t[e]}removeItem(e){this.validateString(e),this.store.delete(e)}setItem(e,t){this.validateString(e),this.validateString(t),this.store.set(String(e),String(t))}validateString(e){if("string"!=typeof e)throw new TypeError("Key must be a string")}}class lt extends yt{static create(){return new yt(new ut)}}class pt extends Error{}function wt(e,t,s,r){if("a"===s&&!r)throw new TypeError("Private accessor was defined without a getter");if("function"==typeof t?e!==t||!r:!t.has(e))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===s?r:"a"===s?r.call(e):r?r.value:t.get(e)}function ft(e,t,s,r,n){if("m"===r)throw new TypeError("Private method is not writable");if("a"===r&&!n)throw new TypeError("Private accessor was defined without a setter");if("function"==typeof t?e!==t||!n:!t.has(e))throw new TypeError("Cannot write private member to an object whose class did not declare it");return"a"===r?n.call(e,s):n?n.value=s:t.set(e,s),s}"function"==typeof SuppressedError&&SuppressedError;class mt{constructor(e){if(!e.publicKey.signature)throw new Error("Provided public key is not signed");this.identityKey=e}async createToken(e){const t=$e.create(this.identityKey.publicKey.walletSignatureAddress(),e||new Date).toBytes(),n=f(t),i=await this.identityKey.sign(v(n));return new je(c.Token.fromPartial({identityKey:r.PublicKey.fromPartial(this.identityKey.publicKey),authDataBytes:t,authDataSignature:s.Signature.fromPartial(i)}))}}const gt=new(0,A.ec)("secp256k1"),vt=D.subtle,bt=Buffer.from("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141","hex"),Et=Buffer.alloc(32,0);function Kt(e,t){if(!e)throw new Error(t||"Assertion failed")}function kt(e){return t=e,!(!Buffer.isBuffer(t)||32!==t.length)&&(e.compare(Et)>0&&e.compare(bt)<0);var t}function Pt(e){const t=new Uint8Array(e);return D.getRandomValues(t),Buffer.from(t)}async function St(e){const t=await vt.digest("SHA-512",e);return Buffer.from(t)}function At(e){return function(t,s,r){return new Promise((function(n){return vt.importKey("raw",s,{name:"AES-CBC"},!1,[e]).then((function(s){const n={name:"AES-CBC",iv:t};return vt[e](n,s,r)})).then((function(e){n(Buffer.from(new Uint8Array(e)))}))}))}}const Tt=At("encrypt"),Ct=At("decrypt");async function It(e,t){const s=await vt.importKey("raw",e,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]);return Buffer.from(await vt.sign({name:"HMAC",hash:"SHA-256"},s,t))}function Bt(e){return Kt(32===e.length,"Bad private key"),Kt(kt(e),"Bad private key"),Buffer.from(gt.keyFromPrivate(e).getPublic("array"))}function Rt(e,t){return new Promise((function(s){Kt(Buffer.isBuffer(e),"Bad private key"),Kt(Buffer.isBuffer(t),"Bad public key"),Kt(32===e.length,"Bad private key"),Kt(kt(e),"Bad private key"),Kt(65===t.length||33===t.length,"Bad public key"),65===t.length&&Kt(4===t[0],"Bad public key"),33===t.length&&Kt(2===t[0]||3===t[0],"Bad public key");const r=gt.keyFromPrivate(e),n=gt.keyFromPublic(t),i=r.derive(n.getPublic());s(Buffer.from(i.toArray()))}))}async function Nt(e,t){const s=await Rt(e,t.ephemeralPublicKey),r=await St(s),n=r.slice(0,32),i=r.slice(32),a=Buffer.concat([t.iv,t.ephemeralPublicKey,t.ciphertext]);return Kt(await async function(e,t,s){return function(e,t){if(e.length!==t.length)return!1;let s=0;for(let r=0;r<e.length;r++)s|=e[r]^t[r];return 0===s}(await It(e,t),s)}(i,a,t.mac),"Bad mac"),Ct(t.iv,n,t.ciphertext)}async function Dt(e,t){await T();const s=e.publicKey.secp256k1Uncompressed.bytes,r=e.secp256k1.bytes;return C(s,r,t)}async function Mt(e,t){await T();const s=e.publicKey.secp256k1Uncompressed.bytes,r=e.secp256k1.bytes;return I(s,r,t)}class xt{constructor({topic:e,context:t,aes256GcmHkdfSha256:s,consentProof:r}){if(!e||!e.length)throw new Error("Missing topic");if(!s||!s.keyMaterial||!s.keyMaterial.length)throw new Error("Missing key material");this.topic=e,this.context=t,this.aes256GcmHkdfSha256=s,this.consentProof=r}static createRandom(e,t){const s=Ae(Buffer.from(D.getRandomValues(new Uint8Array(32))).toString("base64").replace(/=*$/g,"").replace(/\//g,"-")),r=D.getRandomValues(new Uint8Array(32));return new xt({topic:s,aes256GcmHkdfSha256:{keyMaterial:r},context:e,consentProof:t})}toBytes(){return h.InvitationV1.encode(this).finish()}static fromBytes(e){return new xt(h.InvitationV1.decode(e))}}class _t{constructor({sender:e,recipient:t,createdNs:s}){if(!e)throw new Error("Missing sender");if(!t)throw new Error("Missing recipient");this.sender=new ce(e),this.recipient=new ce(t),this.createdNs=s}toBytes(){return h.SealedInvitationHeaderV1.encode(this).finish()}static fromBytes(e){return new _t(h.SealedInvitationHeaderV1.decode(e))}}class Vt{constructor({headerBytes:e,ciphertext:t}){if(!e||!e.length)throw new Error("Missing header bytes");if(!t)throw new Error("Missing ciphertext");this.headerBytes=e,this.ciphertext=new N(t)}get header(){return this._header||(this._header=_t.fromBytes(this.headerBytes)),this._header}async getInvitation(e){if(this._invitation)return this._invitation;const t=this.header;let s;s=e.identityKey.matches(this.header.sender.identityKey)?await e.sharedSecret(t.recipient,t.sender.preKey,!1):await e.sharedSecret(t.sender,t.recipient.preKey,!0);const r=await U(this.ciphertext,s,this.headerBytes);return this._invitation=xt.fromBytes(r),this._invitation}toBytes(){return h.SealedInvitationV1.encode(this).finish()}static fromBytes(e){return new Vt(h.SealedInvitationV1.decode(e))}}class Ut{constructor({v1:e}){if(!e)throw new Error("Missing v1 or v2 invitation");this.v1=new Vt(e)}toBytes(){return h.SealedInvitation.encode(this).finish()}static fromBytes(e){return new Ut(h.SealedInvitation.decode(e))}static async fromEnvelope(e){if(!e.message||!e.timestampNs)throw new Error("invalid invitation envelope");const t=Ut.fromBytes(e.message),s=l.fromString(e.timestampNs),r=t.v1?.header.createdNs;if(!r||!r.equals(s))throw new Error("envelope and header timestamp mistmatch");return t}static async createV1({sender:e,recipient:t,created:s,invitation:r}){const n=new _t({sender:e.getPublicKeyBundle(),recipient:t,createdNs:me(s)}).toBytes(),i=await e.sharedSecret(t,e.getCurrentPreKey().publicKey,!1),a=r.toBytes(),o=await V(a,i,n);return new Ut({v1:{headerBytes:n,ciphertext:o}})}}var Ot,qt,Lt,Gt,Ht,Ft;class $t{constructor(e,t,s=new Map){Ot.add(this),qt.set(this,void 0),Lt.set(this,void 0),Gt.set(this,void 0),Ht.set(this,void 0),ft(this,Lt,t,"f"),ft(this,qt,e,"f"),ft(this,Ht,0,"f"),ft(this,Gt,new S,"f"),this.actionsMap=s}get revisionKey(){return wt(this,Lt,"f")+"/revision"}static async create(e){const t=new $t(e,"private-preferences/actions");return await t.refresh(),t}async refresh(){const e=await this.getRevision();e>wt(this,Ht,"f")&&(this.actionsMap=await this.loadFromPersistence()),ft(this,Ht,e,"f")}async getRevision(){const e=await wt(this,qt,"f").getItem(this.revisionKey);return e?fe(e):0}async setRevision(e){await wt(this,qt,"f").setItem(this.revisionKey,we(e))}async loadFromPersistence(){const e=await wt(this,qt,"f").getItem(wt(this,Lt,"f"));if(!e)return new Map;const t=i.PrivatePreferencesActionMap.decode(e),s=new Map,r=Object.entries(t.actions);for(let e=0;e<r.length;e++)s.set(r[e][0],r[e][1]);return s}async store(){var e;await wt(this,qt,"f").setItem(wt(this,Lt,"f"),wt(this,Ot,"m",Ft).call(this)),ft(this,Ht,(e=wt(this,Ht,"f"),++e),"f"),await this.setRevision(wt(this,Ht,"f"))}async add(e){await wt(this,Gt,"f").runExclusive((async()=>{await this.refresh();let t=!1;const s=Array.from(e.keys());for(let r=0;r<s.length;r++)this.actionsMap.has(s[r])||(this.actionsMap.set(s[r],e.get(s[r])),t=!0);t&&await this.store()}))}get actions(){return new Map([...this.actionsMap.entries()].sort(((e,t)=>be(e[0]).getTime()-be(t[0]).getTime())))}lookup(e){return this.actionsMap.get(e)}}qt=new WeakMap,Lt=new WeakMap,Gt=new WeakMap,Ht=new WeakMap,Ot=new WeakSet,Ft=function(){return i.PrivatePreferencesActionMap.encode({actions:Object.fromEntries(this.actionsMap)}).finish()};const jt=(e,t)=>e instanceof Ee?e:new Ee(t,e.message),Xt=(e,t,s)=>Promise.all(e.map((async e=>{try{return{result:await t(e)}}catch(e){return{error:jt(e,s)}}}))),Jt=e=>e instanceof de?e:new de(e),zt=(e,t,s)=>{for(const s of t)if(!e[s])throw new Ee(i.ErrorCode.ERROR_CODE_INVALID_INPUT,`Missing field ${String(s)}`);for(const t of s){const s=e[t];if(!s||!s?.length)throw new Ee(i.ErrorCode.ERROR_CODE_INVALID_INPUT,`Missing field ${String(t)}`)}return!0},Wt=e=>{if(!e?.aes256GcmHkdfSha256?.keyMaterial)throw new Ee(i.ErrorCode.ERROR_CODE_INVALID_INPUT,"Missing key material");return e.aes256GcmHkdfSha256.keyMaterial},Yt=({invitation:e,createdNs:t,peerAddress:s})=>({context:e.context,topic:e.topic,peerAddress:s,createdNs:t,consentProofPayload:e.consentProof});class Qt{constructor(e,t,s=new Map){this.persistenceKey=t,this.persistence=e,this.revision=0,this.mutex=new S,this.topicMap=s}get revisionKey(){return this.persistenceKey+"/revision"}static async create(e){const t=new Qt(e,"invitations/v1");return await t.refresh(),t}validate(e){return!!e.topic&&e.topic.length>0&&!!e.invitation}async refresh(){const e=await this.getRevision();if(e>this.revision)for(const[e,t]of await this.loadFromPersistence())this.topicMap.set(e,t);this.revision=e}async getRevision(){const e=await this.persistence.getItem(this.revisionKey);return e?fe(e):0}async setRevision(e){await this.persistence.setItem(this.revisionKey,we(e))}async loadFromPersistence(){const e=await this.persistence.getItem(this.persistenceKey);return e?(e=>{const t=new Map;for(const[s,r]of Object.entries(e.topics))t.set(s,r);return t})(i.TopicMap.decode(e)):new Map}async store(){await this.persistence.setItem(this.persistenceKey,this.toBytes()),this.revision++,await this.setRevision(this.revision)}async add(e){await this.mutex.runExclusive((async()=>{await this.refresh();let t=!1;for(const s of e){if(!this.validate(s)){console.warn("Invalid topic data",s.topic);continue}const{topic:e,...r}=s;this.topicMap.has(e)||(this.topicMap.set(e,r),t=!0)}t&&await this.store()}))}get topics(){return[...this.topicMap.values()]}lookup(e){return this.topicMap.get(e)}toBytes(){return i.TopicMap.encode({topics:Object.fromEntries(this.topicMap)}).finish()}}class Zt extends Qt{static async create(e){const t=new Zt(e,"conversation-v1/v1");return await t.refresh(),t}validate(e){return!!(e.topic&&e.topic.length&&e.peerAddress?.length>0)}}const es=async(e,t,s,r)=>V(s,await e.sharedSecret(t,e.getCurrentPreKey().publicKey,!1),r);var ts;const{ErrorCode:ss}=i,rs=(new TextEncoder).encode("__XMTP__INVITATION__SALT__XMTP__");class ns{constructor(e,t,s,r,n){ts.set(this,void 0),this.v1Keys=e,this.v2Keys=Ge.fromLegacyBundle(e),this.v1Store=t,this.v2Store=s,this.privatePreferencesStore=r,this.authenticator=new mt(e.identityKey),this.jobStatePersistence=n}static async create(e,t){return new ns(e,await Zt.create(t),await Qt.create(t),await $t.create(t),t)}get walletAddress(){return this.v1Keys.identityKey.publicKey.walletSignatureAddress()}async decryptV1(e){const t=await Xt(e.requests,(async e=>{zt(e,["payload","peerKeys"],["headerBytes"]);const{payload:t,peerKeys:s,headerBytes:r,isSender:n}=e,i=await(async(e,t,s,r,n)=>U(s,await e.sharedSecret(t,e.getCurrentPreKey().publicKey,!n),r))(this.v1Keys,Jt(s),t,r,n);return{decrypted:i}}),i.ErrorCode.ERROR_CODE_UNSPECIFIED);return i.DecryptResponse.fromPartial({responses:t})}async decryptV2(e){const t=await Xt(e.requests,(async e=>{zt(e,["payload"],["headerBytes"]);const{payload:t,headerBytes:s,contentTopic:r}=e,n=this.v2Store.lookup(r);if(!n)throw new Ee(i.ErrorCode.ERROR_CODE_NO_MATCHING_PREKEY,"no topic key");const a=await((e,t,s)=>U(e,t,s))(t,Wt(n.invitation),s);return{decrypted:a}}),ss.ERROR_CODE_UNSPECIFIED);return i.DecryptResponse.fromPartial({responses:t})}async encryptV1(e){const t=await Xt(e.requests,(async e=>{zt(e,["payload","recipient"],["headerBytes"]);const{recipient:t,payload:s,headerBytes:r}=e;return{encrypted:await es(this.v1Keys,Jt(t),s,r)}}),ss.ERROR_CODE_UNSPECIFIED);return i.EncryptResponse.fromPartial({responses:t})}async createAuthToken({timestampNs:e}){return this.authenticator.createToken(e?ge(e):void 0)}async selfEncrypt(e){const t=await Xt(e.requests,(async e=>{const{payload:t}=e;if(!t)throw new Ee(ss.ERROR_CODE_INVALID_INPUT,"Missing field payload");return{encrypted:await Dt(this.v1Keys.identityKey,t)}}),ss.ERROR_CODE_INVALID_INPUT);return i.SelfEncryptResponse.fromPartial({responses:t})}async selfDecrypt(e){const t=await Xt(e.requests,(async e=>{const{payload:t}=e;if(!t)throw new Ee(ss.ERROR_CODE_INVALID_INPUT,"Missing field payload");return{decrypted:await Mt(this.v1Keys.identityKey,t)}}),ss.ERROR_CODE_INVALID_INPUT);return i.DecryptResponse.fromPartial({responses:t})}async getPrivatePreferencesTopicIdentifier(){const e=await async function(e){await T();const t=e.secp256k1.bytes;return B(t)}(this.v1Keys.identityKey);return i.GetPrivatePreferencesTopicIdentifierResponse.fromPartial({identifier:e})}async encryptV2(e){const t=await Xt(e.requests,(async e=>{zt(e,["payload"],["headerBytes"]);const{payload:t,headerBytes:s,contentTopic:r}=e,n=this.v2Store.lookup(r);if(!n)throw new Ee(ss.ERROR_CODE_NO_MATCHING_PREKEY,"no topic key");const i=Wt(n.invitation),a=await((e,t,s)=>V(e,t,s))(t,i,s),o=`${Math.floor(Date.now()/1e3/60/60/24/30)}-${await this.getAccountAddress()}`;return{encrypted:a,senderHmac:await G(i,(new TextEncoder).encode(o),s)}}),ss.ERROR_CODE_INVALID_INPUT);return i.EncryptResponse.fromPartial({responses:t})}async saveInvites(e){const t=[],s=await Xt(e.requests,(async({payload:e,timestampNs:s})=>{const r=Ut.fromBytes(e);if(r.v1){if(!r.v1.header.createdNs.equals(s))throw new Error("envelope and header timestamp mismatch");const e=r.v1.header.sender.equals(this.v2Keys.getPublicKeyBundle()),n=await r.v1.getInvitation(this.v2Keys),i={invitation:n,createdNs:r.v1.header.createdNs,peerAddress:e?await r.v1.header.recipient.walletSignatureAddress():await r.v1.header.sender.walletSignatureAddress()};return t.push({...i,topic:n.topic}),{conversation:Yt(i)}}}),ss.ERROR_CODE_INVALID_INPUT);return await this.v2Store.add(t),i.SaveInvitesResponse.fromPartial({responses:s})}async createInvite(e){try{zt(e,["recipient"],[]);const s=ge(e.createdNs),r=(t=e.recipient)instanceof ce?t:new ce(t),n=await this.getAccountAddress(),a=await r.walletSignatureAddress(),o=await this.v2Keys.sharedSecret(r,this.v2Keys.getCurrentPreKey().publicKey,n<a),c=[n,a].sort(),d=(e.context?.conversationId||"")+c.join(),h=(new TextEncoder).encode(d),y=j(await It(Buffer.from(o),Buffer.from(h))),u=["0",...c].join("|"),l=(new TextEncoder).encode(u),p=await async function(e,t){const s=await D.subtle.importKey("raw",e,"HKDF",!1,["deriveKey"]);return D.subtle.deriveKey({name:"HKDF",hash:"SHA-256",salt:rs,info:t},s,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"])}(o,l),w=new Uint8Array(await D.subtle.exportKey("raw",p)),f=new xt({topic:Ae(y),aes256GcmHkdfSha256:{keyMaterial:w},context:e.context,consentProof:e.consentProof}),m=await Ut.createV1({sender:this.v2Keys,recipient:r,created:s,invitation:f}),g={invitation:f,topic:f.topic,createdNs:e.createdNs,peerAddress:await r.walletSignatureAddress()};return await this.v2Store.add([g]),i.CreateInviteResponse.fromPartial({conversation:Yt(g),payload:m.toBytes()})}catch(e){throw jt(e,ss.ERROR_CODE_INVALID_INPUT)}var t}async signDigest(e){zt(e,["digest"],[]);const{digest:t,identityKey:s,prekeyIndex:r}=e;let n;if(s)n=this.v1Keys.identityKey;else{if(void 0===r||!Number.isInteger(r))throw new Ee(ss.ERROR_CODE_INVALID_INPUT,"must specifify identityKey or prekeyIndex");if(n=this.v1Keys.preKeys[r],!n)throw new Ee(ss.ERROR_CODE_NO_MATCHING_PREKEY,"no prekey found")}return n.sign(t)}async saveV1Conversations({conversations:e}){return await this.v1Store.add(e.map((e=>({topic:Se(e.peerAddress,this.walletAddress),peerAddress:e.peerAddress,createdNs:e.createdNs,invitation:void 0})))),{}}async getV1Conversations(){return{conversations:this.v1Store.topics.map(this.topicDataToV1ConversationReference.bind(this))}}async getV2Conversations(){const e=this.v2Store.topics.map((e=>Yt(e)));return e.sort(((e,t)=>e.createdNs.div(1e6).sub(t.createdNs.div(1e6)).toNumber())),i.GetConversationsResponse.fromPartial({conversations:e})}async getPublicKeyBundle(){return this.v1Keys.getPublicKeyBundle()}async getPrivateKeyBundle(){return this.v1Keys}async getAccountAddress(){return this.accountAddress||(this.accountAddress=await this.v2Keys.getPublicKeyBundle().walletSignatureAddress()),this.accountAddress}async getRefreshJob({jobType:e}){if(e===i.JobType.JOB_TYPE_UNSPECIFIED)throw new Ee(ss.ERROR_CODE_INVALID_INPUT,"invalid job type");const t=await this.getLastRunTime(e);return i.GetRefreshJobResponse.fromPartial({lastRunNs:t||l.fromNumber(0)})}async setRefreshJob({jobType:e,lastRunNs:t}){const s=await this.buildJobStorageKey(e);return await this.jobStatePersistence.setItem(s,Uint8Array.from(t.toBytes())),{}}topicDataToV1ConversationReference(e){return{peerAddress:e.peerAddress,createdNs:e.createdNs,topic:Se(e.peerAddress,this.walletAddress),context:void 0,consentProofPayload:void 0}}buildJobStorageKey(e){return`refreshJob/${e.toString()}`}async getLastRunTime(e){const t=await this.jobStatePersistence.getItem(this.buildJobStorageKey(e));if(t&&t.length)return l.fromBytes([...t])}lookupTopic(e){return this.v2Store.lookup(e)}async getV2ConversationHmacKeys(e){const t=Math.floor(Date.now()/1e3/60/60/24/30),s={};let r=this.v2Store.topics;return e?.topics&&(r=r.filter((t=>void 0!==t.invitation&&e.topics.includes(t.invitation.topic)))),await Promise.all(r.map((async e=>{if(e.invitation?.topic){const r=Wt(e.invitation),n=await Promise.all([t-1,t,t+1].map((async e=>{const t=`${e}-${await this.getAccountAddress()}`,s=await L(r,(new TextEncoder).encode(t));return{thirtyDayPeriodsSinceEpoch:e,hmacKey:await F(s)}})));s[e.invitation.topic]={values:n}}}))),{hmacKeys:s}}async getPrivatePreferencesTopic(){if(!wt(this,ts,"f")){const{identifier:e}=await this.getPrivatePreferencesTopicIdentifier();ft(this,ts,(e=>Pe(`userpreferences-${e}`))(e),"f")}return wt(this,ts,"f")}async createPrivatePreference(e){const{responses:t}=await this.selfEncrypt({requests:[{payload:y.PrivatePreferencesAction.encode(e).finish()}]}),s=t.reduce(((e,t)=>t.result?.encrypted?e.concat(t.result?.encrypted):e),[]),r=await this.getPrivatePreferencesTopic(),n=new Date;return s.map((e=>({contentTopic:r,message:e,timestamp:n})))}getPrivatePreferences(){return this.privatePreferencesStore.actions}savePrivatePreferences(e){return this.privatePreferencesStore.add(e)}}ts=new WeakMap;class is{constructor(e){this.apiClient=e}async getItem(e){for await(const t of this.apiClient.queryIterator({contentTopic:this.buildTopic(e)},{pageSize:1,direction:d.SortDirection.SORT_DIRECTION_DESCENDING}))if(t.message)try{return Uint8Array.from(t.message)}catch(e){console.log(e)}return null}async setItem(e,t){const s=Uint8Array.from(t);await this.apiClient.publish([{contentTopic:this.buildTopic(e),message:s}])}setAuthenticator(e){this.apiClient.setAuthenticator(e)}buildTopic(e){return Be(e)}}class as{constructor({eciesBytes:t,signature:s}){if(!t||!t.length)throw new Error("eciesBytes is empty");if(!s)throw new Error("signature is undefined");this.eciesBytes=t,this.signature=new te(s),this.ciphertext=e.SignedEciesCiphertext_Ecies.decode(t)}toBytes(){return e.SignedEciesCiphertext.encode(this).finish()}async verify(e){return e.verify(this.signature,await _(this.eciesBytes))}static fromBytes(t){const s=e.SignedEciesCiphertext.decode(t);return new as(s)}static async create(t,s){(e=>{if(16!==e.iv.length)throw new Error("Invalid iv length");if(65!==e.ephemeralPublicKey.length)throw new Error("Invalid ephemPublicKey length");if(e.ciphertext.length<1||e.ciphertext.length%16!=0)throw new Error("Invalid ciphertext length");if(32!==e.mac.length)throw new Error("Invalid mac length")})(t);const r=e.SignedEciesCiphertext_Ecies.encode(t).finish(),n=await s.sign(await _(r));return new as({eciesBytes:r,signature:n})}}class os{constructor(e,t){this.persistence=e,this.privateKey=t,this.privateKeyBytes=Buffer.from(t.secp256k1.bytes),this.publicKey=Bt(this.privateKeyBytes)}async getItem(e){const t=await this.persistence.getItem(e);return t?this.decrypt(t):null}async setItem(e,t){const s=await this.encrypt(t);await this.persistence.setItem(e,s)}async encrypt(e){const t=await async function(e,t,s){s=s||{};const r=s?.iv||Pt(16);let n=s?.ephemPrivateKey||Pt(32);for(;!kt(n);){if(s?.ephemPrivateKey)throw new Error("ephemPrivateKey is not valid");n=Pt(32)}const i=Bt(n),a=await St(await Rt(n,e)),o=a.slice(0,32),c=a.slice(32),d=await Tt(r,o,t),h=Buffer.concat([r,i,d]);return{iv:r,ephemeralPublicKey:i,ciphertext:d,mac:await It(c,h)}}(this.publicKey,Buffer.from(e));return this.serializeEcies(t)}async decrypt(e){const t=await this.deserializeEcies(e),s=await Nt(this.privateKeyBytes,t);return Uint8Array.from(s)}async serializeEcies(e){return(await as.create(e,this.privateKey)).toBytes()}async deserializeEcies(e){const t=as.fromBytes(e);if(!await t.verify(this.privateKey.publicKey))throw new Error("signature validation failed");const s=t.ciphertext;return{ciphertext:Buffer.from(s.ciphertext),mac:Buffer.from(s.mac),iv:Buffer.from(s.iv),ephemeralPublicKey:Buffer.from(s.ephemeralPublicKey)}}}class cs{constructor(e,t){this.prefix=e,this.persistence=t}getItem(e){return this.persistence.getItem(this.buildKey(e))}setItem(e,t){return this.persistence.setItem(this.buildKey(e),t)}buildKey(e){return this.prefix+e}}const ds=async(e,t)=>{if(!e.persistConversations)return lt.create();const s=await t.identityKey.publicKey.walletSignatureAddress(),r=`xmtp/${e.env}/${s}/`;const n=e.basePersistence,i=!e.disablePersistenceEncryption;return new cs(r,i?new os(n,t.identityKey):n)},hs="key_bundle";class ys{constructor(e,t,s){this.signer=e,this.persistence=t,this.preEnableIdentityCallback=s}async getStorageAddress(e){let t=await this.signer.getAddress();return t=m(t),`${t}/${e}`}async loadPrivateKeyBundle(){const e=await this.persistence.getItem(await this.getStorageAddress(hs));if(!e)return null;const[t,s]=await this.fromEncryptedBytes(this.signer,Uint8Array.from(e));return s&&await this.storePrivateKeyBundle(t),t}async storePrivateKeyBundle(e){const t=await this.getStorageAddress(hs),s=await this.toEncryptedBytes(e,this.signer);"function"==typeof this.persistence.setAuthenticator&&this.persistence.setAuthenticator(new mt(e.identityKey)),await this.persistence.setItem(t,s)}async toEncryptedBytes(e,s){const r=e.encode(),n=D.getRandomValues(new Uint8Array(32)),i=ls(n),a=await s.getAddress();this.preEnableIdentityCallback&&await this.preEnableIdentityCallback();const o=await s.signMessage(i);if(!E({address:a,message:i,signature:o}))throw new Error("invalid signature");const c=v(o),d=await V(r,c);return t.EncryptedPrivateKeyBundle.encode({v1:{walletPreKey:n,ciphertext:d}}).finish()}async fromEncryptedBytes(e,s){const[r,n]=function(e){try{const s=t.EncryptedPrivateKeyBundle.decode(e);if(s.v1)return[s.v1,!1]}catch(s){return[t.EncryptedPrivateKeyBundleV1.decode(e),!0]}throw new Error("unrecognized encrypted private key bundle version")}(s);if(!r.walletPreKey)throw new Error("missing wallet pre-key");if(!r.ciphertext?.aes256GcmHkdfSha256)throw new Error("missing bundle ciphertext");this.preEnableIdentityCallback&&await this.preEnableIdentityCallback();const i=v(await e.signMessage(ls(r.walletPreKey)));try{const e=new N(r.ciphertext),t=await U(e,i),[s,a]=us(t);return[s,n||a]}catch(e){if(65!==i.length)throw new Error("Expected 65 bytes before trying a different recovery byte");const t=i[i.length-1];let s=i.slice(0,i.length-1);s=t<27?new Uint8Array([...s,t+27]):new Uint8Array([...s,t-27]);const a=new N(r.ciphertext),o=await U(a,s),[c,d]=us(o);return[c,n||d]}}}function us(e){try{const t=Fe(e);if(t instanceof Ge)throw new Error("V2 bundles not supported yet");return[t,!1]}catch(s){const r=t.PrivateKeyBundleV1.decode(e);return[new He(r),!0]}}function ls(e){return`XMTP : Enable Identity\n${j(e)}\n\nFor more info: https://xmtp.org/signatures/`}class ps{async newKeystore(e,t,s){if(!s)throw new pt("Wallet required to generate new keys");e.preCreateIdentityCallback&&await e.preCreateIdentityCallback();const r=await He.generate(s),n=new ys(s,new is(t),e.preEnableIdentityCallback);return await n.storePrivateKeyBundle(r),ns.create(r,await ds(e,r))}}class ws{async newKeystore(e,t,s){if(!s)throw new pt("No wallet provided");const r=new ys(s,new is(t),e.preEnableIdentityCallback),n=await r.loadPrivateKeyBundle();if(!n)throw new pt("No keys found");return ns.create(n,await ds(e,n))}}function fs(){return window.ethereum}function ms(e){const[t,s,...r]=e.split(".");return{major:Number(t),minor:Number(s),patch:r.join(".")}}function gs(e,t){if(!e||!t)return!1;const s=ms(e),r=ms(t);return s.major!==r.major?s.major>r.major:s.minor!==r.minor?s.minor>r.minor:!(!s.patch||!r.patch)&&function(e,t){const[s,r]=e.split("-"),[n,i]=t.split("-");if(Number(s)!==Number(n))return Number(s)>Number(n);if(!r||!i)return!1;const[a,o]=r.split("."),[c,d]=i.split(".");if(a!==c)return!0;return Number(o)>Number(d)}(s.patch,r.patch)}const{GetKeystoreStatusResponse_KeystoreStatus:vs,InitKeystoreRequest:bs,InitKeystoreResponse:Es,GetKeystoreStatusRequest:Ks,GetKeystoreStatusResponse:ks}=i;async function Ps(e,t,s,r,n){let i=null;if(t.req){const e=(0,t.req.encode)(s).finish();i=le(e,0,e.length)}const a=await async function(e,t,s,r){const n={meta:s};"string"==typeof t&&(n.req=t);const i=await(fs()?.request({method:"wallet_invokeSnap",params:{snapId:r,request:{method:e,params:n}}}));if(!i||"object"!=typeof i)throw new Error("No response value");return i.res}(e,i,r,n);if(Array.isArray(a))throw new Error("Unexpected array response");return t.res.decode(ue(a))}async function Ss(){const e=fs();if(e?.isMetaMask)try{return await e.request({method:"wallet_getSnaps"}),!0}catch{}if(void 0!==e?.detected&&Array.isArray(e.detected))for(const t of e.detected)try{return await t.request({method:"wallet_getSnaps"}),e?.setProvider?.(t),!0}catch{}if(void 0!==e?.providers&&Array.isArray(e.providers))for(const t of e.providers)try{return await t.request({method:"wallet_getSnaps"}),window.ethereum=t,!0}catch{}return!1}async function As(e,t){try{const s=await async function(){return await(fs()?.request({method:"wallet_getSnaps"}))}();return s?Object.values(s).find((s=>{return s&&s.id===e&&(!t||(r=s.version,n=t,!r||!n||ms(r).major===ms(n).major));var r,n})):void 0}catch(e){return void console.warn("Failed to obtain installed snap",e)}}const Ts={req:Ks,res:ks};const Cs={req:bs,res:Es};const Is={decryptV1:{req:i.DecryptV1Request,res:i.DecryptResponse},decryptV2:{req:i.DecryptV2Request,res:i.DecryptResponse},encryptV1:{req:i.EncryptV1Request,res:i.EncryptResponse},encryptV2:{req:i.EncryptV2Request,res:i.EncryptResponse},saveInvites:{req:i.SaveInvitesRequest,res:i.SaveInvitesResponse},createInvite:{req:i.CreateInviteRequest,res:i.CreateInviteResponse},createAuthToken:{req:i.CreateAuthTokenRequest,res:c.Token},signDigest:{req:i.SignDigestRequest,res:s.Signature},getPublicKeyBundle:{req:null,res:r.PublicKeyBundle},getPrivateKeyBundle:{req:null,res:t.PrivateKeyBundleV1},saveV1Conversations:{req:i.SaveV1ConversationsRequest,res:i.SaveV1ConversationsResponse},getV1Conversations:{req:null,res:i.GetConversationsResponse},getV2Conversations:{req:null,res:i.GetConversationsResponse},getRefreshJob:{req:i.GetRefreshJobRequest,res:i.GetRefreshJobResponse},setRefreshJob:{req:i.SetRefeshJobRequest,res:i.SetRefreshJobResponse},selfEncrypt:{req:i.SelfEncryptRequest,res:i.SelfEncryptResponse},selfDecrypt:{req:i.SelfDecryptRequest,res:i.DecryptResponse},getPrivatePreferencesTopicIdentifier:{req:null,res:i.GetPrivatePreferencesTopicIdentifierResponse},getV2ConversationHmacKeys:{req:i.GetConversationHmacKeysRequest,res:i.GetConversationHmacKeysResponse}},Bs={getKeystoreStatus:{req:i.GetKeystoreStatusRequest,res:i.GetKeystoreStatusResponse},initKeystore:{req:i.InitKeystoreRequest,res:i.InitKeystoreResponse}};const{GetKeystoreStatusResponse_KeystoreStatus:Rs}=i;class Ns{constructor(e="local:http://localhost:8080",t){this.snapId=e,this.snapVersion=t}async newKeystore(e,t,s){if(!s)throw new pt("No wallet provided");if(!await Ss())throw new pt("MetaMask with Snaps not detected");const r=await s.getAddress(),n=e.env,i=await As(this.snapId,this.snapVersion);if(i&&!gs(this.snapVersion,i.version)||await async function(e,t={}){await(fs()?.request({method:"wallet_requestSnaps",params:{[e]:t}}))}(this.snapId,this.snapVersion?{version:this.snapVersion}:{}),!await async function(e,t,s){const r=await async function(e,t){const s=await Ps("getKeystoreStatus",Ts,{walletAddress:e.walletAddress},e,t);if([vs.KEYSTORE_STATUS_UNSPECIFIED,vs.UNRECOGNIZED].includes(s.status))throw new Error("No status specified in response");return s.status}({walletAddress:e,env:t},s);if(r===Rs.KEYSTORE_STATUS_INITIALIZED)return!0;return!1}(r,n,this.snapId)){const r=await async function(e,t,s){if(e.privateKeyOverride){const t=Fe(e.privateKeyOverride);if(!(t instanceof He))throw new Error("Unsupported private key bundle version");return t}if(!s)throw new Error("No privateKeyOverride or wallet");return async function(e,t,s){const r=new ws;try{const n=await r.newKeystore(e,t,s);return new He(await n.getPrivateKeyBundle())}catch(r){if(r instanceof pt)return async function(e,t,s){const r=new ps,n=await r.newKeystore(e,t,s);return new He(await n.getPrivateKeyBundle())}(e,t,s);throw r}}(e,t,s)}(e,t,s);await async function(e,t,s){const r=e.identityKey.publicKey.walletSignatureAddress(),n=await Ps("initKeystore",Cs,{v1:e},{walletAddress:r,env:t},s);if(n.error)throw new Ee(n.error.code,n.error.message)}(r,n,this.snapId)}return function(e,t,s){const r={},n={walletAddress:e,env:t};for(const[e,t]of Object.entries(Bs))r[e]=async r=>t.req?Ps(e,t,r,n,s):Ps(e,t,void 0,n,s);return{...r,getAccountAddress:async()=>e}}(r,n,this.snapId)}}class Ds{async newKeystore(e){const{privateKeyOverride:t}=e;if(!t)throw new pt("No private key override provided");const s=Fe(t);if(s instanceof Ge)throw new Error("V2 private key bundle found. Only V1 supported");return ns.create(s,await ds(e,s))}}function Ms(e){if(!e)return null;if(function(e){return"type"in e&&("walletClient"===e.type||"base"===e.type)}(e))return function(e){const{account:t}=e;if(!t||!t.address)throw new Error("WalletClient is not configured");return{getAddress:async()=>t.address,signMessage:async s=>e.signMessage({message:"string"==typeof s?s:{raw:s},account:t})}}(e);if("function"!=typeof e.getAddress)throw new Error("Unknown wallet type");return e}function xs(e){if(e===o.Compression.COMPRESSION_GZIP)return"gzip";if(e===o.Compression.COMPRESSION_DEFLATE)return"deflate";throw new Error("unrecognized compression algorithm")}function _s(e,t=1024){let s=0;return new ReadableStream({pull(r){if(s>=e.length)return r.close();let n=s+t;n=n<=e.length?n:e.length,r.enqueue(e.subarray(s,n)),s=n}})}function Vs(e,t){let s=0;return new WritableStream({write(r){const n=s+r.length;if(n>t)throw new Error("maximum output size exceeded");for(;e.bytes.length<n;)e.bytes=Us(e.bytes,t);e.bytes.set(r,s),s=n},close(){s<e.bytes.length&&(e.bytes=e.bytes.subarray(0,s))}})}function Us(e,t){let s=2*e.length;s>t&&(s=t);const r=new Uint8Array(s);return r.set(e),r}function Os(e){let t;try{t=u.ContactBundle.decode(e)}catch(s){const n=r.PublicKeyBundle.decode(e);t={v1:{keyBundle:new de(n)},v2:void 0}}if(t.v1?.keyBundle)return new de(t.v1.keyBundle);if(t.v2?.keyBundle)return new ce(t.v2.keyBundle);throw new Error("unknown or invalid contact bundle")}function qs(e){return e instanceof de?u.ContactBundle.encode({v1:{keyBundle:e},v2:void 0}).finish():u.ContactBundle.encode({v1:void 0,v2:{keyBundle:e}}).finish()}var Ls,Gs,Hs,Fs,$s;class js{constructor(e,t,s){this.value=e,this.entryType=t,this.permissionType=s}get key(){return`${this.entryType}-${this.value}`}static fromAddress(e,t="unknown"){return new js(e,"address",t)}static fromGroupId(e,t="unknown"){return new js(e,"groupId",t)}static fromInboxId(e,t="unknown"){return new js(e,"inboxId",t)}}class Xs{constructor(e){this.entries=new Map,this.client=e}allow(e){const t=js.fromAddress(e,"allowed");return this.entries.set(t.key,"allowed"),t}deny(e){const t=js.fromAddress(e,"denied");return this.entries.set(t.key,"denied"),t}allowGroup(e){const t=js.fromGroupId(e,"allowed");return this.entries.set(t.key,"allowed"),t}denyGroup(e){const t=js.fromGroupId(e,"denied");return this.entries.set(t.key,"denied"),t}allowInboxId(e){const t=js.fromInboxId(e,"allowed");return this.entries.set(t.key,"allowed"),t}denyInboxId(e){const t=js.fromInboxId(e,"denied");return this.entries.set(t.key,"denied"),t}state(e){const t=js.fromAddress(e);return this.entries.get(t.key)??"unknown"}groupState(e){const t=js.fromGroupId(e);return this.entries.get(t.key)??"unknown"}inboxIdState(e){const t=js.fromInboxId(e);return this.entries.get(t.key)??"unknown"}async decodeMessages(e){const t=Array.from(e.values()),{responses:s}=await this.client.keystore.selfDecrypt({requests:t.map((e=>({payload:e})))}),r=Array.from(e.keys()).map(((e,t)=>[e,s[t]])).reduce(((e,[t,s])=>{if(s.result?.decrypted){const r=y.PrivatePreferencesAction.decode(s.result.decrypted);e.set(t,r)}return e}),new Map);return await this.client.keystore.savePrivatePreferences(r),r}processActions(e){Array.from(e.values()).forEach((e=>{e.allowAddress?.walletAddresses.forEach((e=>{this.allow(e)})),e.denyAddress?.walletAddresses.forEach((e=>{this.deny(e)})),e.allowGroup?.groupIds.forEach((e=>{this.allowGroup(e)})),e.denyGroup?.groupIds.forEach((e=>{this.denyGroup(e)})),e.allowInboxId?.inboxIds.forEach((e=>{this.allowInboxId(e)})),e.denyInboxId?.inboxIds.forEach((e=>{this.denyInboxId(e)}))}))}async stream(e){const t=await this.client.keystore.getPrivatePreferencesTopic();return ye.create(this.client,[t],(async e=>{if(!e.message||!e.timestampNs)return;const t=await this.decodeMessages(new Map([[e.timestampNs,e.message]]));return this.processActions(t),t.get(e.timestampNs)}),void 0,e)}reset(){this.entries.clear()}async load(e){const t=await this.client.keystore.getPrivatePreferencesTopic(),s=(await this.client.listEnvelopes(t,(async({message:e,timestampNs:t})=>[t,e]),{pageSize:500,direction:d.SortDirection.SORT_DIRECTION_ASCENDING,startTime:e})).filter((([e])=>Boolean(e)));await this.decodeMessages(new Map(s));const r=this.client.keystore.getPrivatePreferences();return this.reset(),this.processActions(r),this.entries}async publish(e){const t=e.reduce(((e,t)=>{let s,r,n;if("unknown"===t.permissionType)return e;switch(t.entryType){case"address":s="allowed"===t.permissionType?"allowAddress":"denyAddress",r="walletAddresses",n=e[s]?.[r]??[];break;case"groupId":s="allowed"===t.permissionType?"allowGroup":"denyGroup",r="groupIds",n=e[s]?.[r]??[];break;case"inboxId":s="allowed"===t.permissionType?"allowInboxId":"denyInboxId",r="inboxIds",n=e[s]?.[r]??[];break;default:return e}return{...e,[s]:{[r]:[...n,t.value]}}}),{}),s=await this.client.keystore.createPrivatePreference(t);await this.client.publishEnvelopes(s),this.client.keystore.savePrivatePreferences(new Map([[s[0].timestamp.getTime().toString(),t]])),e.forEach((e=>{this.entries.set(e.key,e.permissionType)}))}}class Js{constructor(e){Ls.add(this),Gs.set(this,void 0),Hs.set(this,void 0),this.addresses=new Set,this.client=e,ft(this,Gs,new Xs(e),"f"),ft(this,Hs,new ct("user-preferences",e.keystore),"f")}async loadConsentList(e){return wt(this,Hs,"f").run((async t=>{const s=await wt(this,Gs,"f").load(e??t);try{const e=(await this.client.conversations.list()).reduce(((e,t)=>t.consentProof&&"unknown"===this.consentState(t.peerAddress)&&wt(this,Ls,"m",Fs).call(this,t.consentProof,t.peerAddress)?e.concat(t.peerAddress):e),[]);e.length&&await this.client.contacts.allow(e)}catch(e){console.log(e)}return s}))}async refreshConsentList(){return wt(this,Gs,"f").reset(),await wt(this,Hs,"f").resetLastRunTime(),this.loadConsentList()}async streamConsentList(e){return wt(this,Gs,"f").stream(e)}setConsentListEntries(e){e.length&&(wt(this,Gs,"f").reset(),e.forEach((e=>{"allowed"===e.permissionType&&wt(this,Gs,"f").allow(e.value),"denied"===e.permissionType&&wt(this,Gs,"f").deny(e.value)})))}isAllowed(e){return"allowed"===wt(this,Gs,"f").state(e)}isDenied(e){return"denied"===wt(this,Gs,"f").state(e)}isGroupAllowed(e){return"allowed"===wt(this,Gs,"f").groupState(e)}isGroupDenied(e){return"denied"===wt(this,Gs,"f").groupState(e)}isInboxAllowed(e){return"allowed"===wt(this,Gs,"f").inboxIdState(e)}isInboxDenied(e){return"denied"===wt(this,Gs,"f").inboxIdState(e)}consentState(e){return wt(this,Gs,"f").state(e)}groupConsentState(e){return wt(this,Gs,"f").groupState(e)}inboxConsentState(e){return wt(this,Gs,"f").inboxIdState(e)}async allow(e){await wt(this,Gs,"f").publish(e.map((e=>js.fromAddress(e,"allowed"))))}async deny(e){await wt(this,Gs,"f").publish(e.map((e=>js.fromAddress(e,"denied"))))}async allowGroups(e){await wt(this,Gs,"f").publish(e.map((e=>js.fromGroupId(e,"allowed"))))}async denyGroups(e){await wt(this,Gs,"f").publish(e.map((e=>js.fromGroupId(e,"denied"))))}async allowInboxes(e){await wt(this,Gs,"f").publish(e.map((e=>js.fromInboxId(e,"allowed"))))}async denyInboxes(e){await wt(this,Gs,"f").publish(e.map((e=>js.fromInboxId(e,"denied"))))}}Gs=new WeakMap,Hs=new WeakMap,Ls=new WeakSet,Fs=function({signature:e,timestamp:t},s){const r=Number(t);if(!e||!r)return!1;if(r>Date.now())return!1;if(r<Date.now()-2592e6)return!1;const n=J(e),i=R(s,r),a=ee(v(b(i)),n);return a?.getEthereumAddress()===this.client.address},function(e){e[e.none=0]="none",e[e.xmtpTopicStore=1]="xmtpTopicStore"}($s||($s={}));const zs=$s.none;class Ws{static createConfiguration(){return{type:zs,version:0}}constructor(e){this.configuration=e}get backupType(){return zs}}const Ys=$s.xmtpTopicStore;class Qs{static createConfiguration(e){return{type:Ys,version:0,topic:"history-v0:"+e}}constructor(e){this.configuration=e}get backupType(){return Ys}}async function Zs(e,t){const s=await async function(e,t){let s;switch((await t()).type){case $s.none:s=Ws.createConfiguration();break;case $s.xmtpTopicStore:s=Qs.createConfiguration(e)}return s}(e,t);switch(s.type){case $s.none:return new Ws(s);case $s.xmtpTopicStore:return new Qs(s)}}const{Compression:er}=o,tr=104857600;class sr{constructor(e,t,s,r){this.knownPublicKeyBundles=new Map,this.keystore=r,this.publicKeyBundle=e,this.address=e.walletSignatureAddress(),this._conversations=new ht(this),this._codecs=new Map,this._maxContentSize=tr,this.apiClient=t,this._backupClient=s,this.contacts=new Js(this)}get conversations(){return this._conversations}get backupType(){return this._backupClient.backupType}get signedPublicKeyBundle(){return ce.fromLegacyBundle(this.publicKeyBundle)}static async create(e,t){const s=Ms(e),r=function(e){const t={privateKeyOverride:void 0,env:"dev",apiUrl:void 0,codecs:[new k],maxContentSize:tr,persistConversations:!0,skipContactPublishing:!1,useSnaps:!1,basePersistence:"undefined"!=typeof window&&void 0!==window.document?yt.create():lt.create(),disablePersistenceEncryption:!1,keystoreProviders:ar(),apiClientFactory:rr};return e?.codecs&&(e.codecs=t.codecs.concat(e.codecs)),e?.useSnaps&&(e.keystoreProviders=[new Ns("npm:@xmtp/snap","1.3.6"),...t.keystoreProviders]),{...t,...e}}(t),n=r.apiClientFactory(r),i=await async function(e,t,s){for(const r of e.keystoreProviders)try{return await r.newKeystore(e,t,s??void 0)}catch(e){if(e instanceof pt)continue;throw e}throw new Error("No keystore providers available")}(r,n,s),a=new de(await i.getPublicKeyBundle()),o=a.walletSignatureAddress();n.setAuthenticator(new Xe(i));const c=await sr.setupBackupClient(o,r.env),d=new sr(a,n,c,i);return await d.init(r),d}static async getKeys(e,t){const s=await sr.create(Ms(e),t),r=await s.keystore.getPrivateKeyBundle();return new He(r).encode()}static isSnapsReady(){return Ss()}static async setupBackupClient(e,t){return Zs(e,(async()=>Promise.resolve({type:"local"===t?$s.xmtpTopicStore:$s.none})))}async init(e){e.codecs.forEach((e=>{this.registerCodec(e)})),this._maxContentSize=e.maxContentSize,e.skipContactPublishing||await this.ensureUserContactPublished(e.publishLegacyContact)}async close(){}async ensureUserContactPublished(e=!1){const t=await nr(this.apiClient,this.address);t&&t instanceof ce&&this.signedPublicKeyBundle.equals(t)||(await this.publishUserContact(!0),e||await this.publishUserContact(e))}async publishUserContact(e=!1){const t=e?this.publicKeyBundle:this.signedPublicKeyBundle;await this.publishEnvelopes([{contentTopic:Te(this.address),message:qs(t)}])}async getUserContact(e){e=m(e);const t=this.knownPublicKeyBundles.get(e);if(t)return t;const s=await nr(this.apiClient,e);return s&&this.knownPublicKeyBundles.set(e,s),s}async getUserContacts(e){const t=e.map((e=>m(e))),s=new Map,r=[];for(const e of t){const t=this.knownPublicKeyBundles.get(e);t?s.set(e,t):(s.set(e,void 0),r.push(e))}const n=await ir(this.apiClient,r);for(let e=0;e<n.length;e++){const t=r[e],i=n[e];s.set(t,i),i&&this.knownPublicKeyBundles.set(t,i)}return t.map((e=>s.get(e)))}forgetContact(e){e=m(e),this.knownPublicKeyBundles.delete(e)}async canMessage(e){try{if(Array.isArray(e)){return(await this.getUserContacts(e)).map((e=>!!e))}return void 0!==await this.getUserContact(e)}catch(e){return!1}}static async canMessage(e,t){const s=new ot(t?.apiUrl||tt[t?.env||"dev"],{appVersion:t?.appVersion});if(Array.isArray(e)){const t=e.map((e=>m(e)));return(await ir(s,t)).map((e=>!!e))}try{e=m(e)}catch(e){return!1}return void 0!==await nr(s,e)}validateEnvelope(e){const t=e.message;if(!e.contentTopic)throw new Error("Missing content topic");if(!t||!t.length)throw new Error("Cannot publish empty message")}async publishEnvelopes(e){for(const t of e)this.validateEnvelope(t);await this.apiClient.publish(e)}registerCodec(e){const t=e.contentType,s=`${t.authorityId}/${t.typeId}`;return this._codecs.set(s,e),this}codecFor(e){const t=`${e.authorityId}/${e.typeId}`,s=this._codecs.get(t);if(s&&!(e.versionMajor>s.contentType.versionMajor))return s}async encodeContent(e,t){const s=t?.contentType||K,r=this.codecFor(s);if(!r)throw new Error("unknown content type "+s);const n=r.encode(e,this),i=r.fallback(e);return i&&(n.fallback=i),"number"==typeof t?.compression&&n.content.length>=10&&(n.compression=t.compression),await async function(e){if(void 0===e.compression)return;const t={bytes:new Uint8Array(e.content.length/10)};await _s(e.content).pipeThrough(new CompressionStream(xs(e.compression))).pipeTo(Vs(t,e.content.length+1e3)),e.content=t.bytes}(n),{payload:o.EncodedContent.encode(n).finish(),shouldPush:r.shouldPush(e)}}async decodeContent(e){const t=o.EncodedContent.decode(e);if(!t.type)throw new Error("missing content type");let s;const r=new P(t.type);let n;await async function(e,t){if(void 0===e.compression)return;const s={bytes:new Uint8Array(e.content.length)};await _s(e.content).pipeThrough(new DecompressionStream(xs(e.compression))).pipeTo(Vs(s,t)),e.content=s.bytes}(t,1e3);const i=this.codecFor(r);return i?s=i.decode(t,this):n=new Error("unknown content type "+r),{content:s,contentType:r,error:n,contentFallback:t.fallback}}listInvitations(e){return this.listEnvelopes(Ie(this.address),(async e=>e),e)}async listEnvelopes(e,t,s){s||(s={});const{startTime:r,endTime:n,limit:i,pageSize:a}=s,o=await this.apiClient.query({contentTopic:e,startTime:r,endTime:n},{direction:s.direction||d.SortDirection.SORT_DIRECTION_ASCENDING,limit:i,pageSize:a}),c=[];for(const e of o)if(e.message)try{const s=await t(e);c.push(s)}catch(e){console.warn("Error in listEnvelopes mapper",e)}return c}listEnvelopesPaginated(e,t,s){return Ye(this.apiClient.queryIteratePages({contentTopic:e,startTime:s?.startTime,endTime:s?.endTime},{direction:s?.direction,pageSize:s?.pageSize||100}),t)}}function rr(e){const t=e.apiUrl||tt[e.env];return new ot(t,{appVersion:e.appVersion})}async function nr(e,t){const s=e.queryIterator({contentTopic:Te(t)},{pageSize:5,direction:et.SORT_DIRECTION_DESCENDING});for await(const e of s){if(!e.message)continue;const s=Os(e.message);let r;try{r=await(s?.walletSignatureAddress())}catch(e){r=void 0}if(r?.toLowerCase()===t.toLowerCase())return s}}async function ir(e,t){const s=t.map(Te),r=await e.batchQuery(s.map((e=>({contentTopic:e,pageSize:5,direction:et.SORT_DIRECTION_DESCENDING}))));return Promise.all(t.map((async(e,t)=>{const s=r[t];if(s)for(const t of s)if(t.message)try{const s=Os(t.message),r=await(s?.walletSignatureAddress());if(e.toLowerCase()===r.toLowerCase())return s;console.info("Received contact bundle with incorrect address")}catch(e){console.info("Invalid contact bundle",e)}})))}function ar(){return[new Ds,new ws,new ps]}export{tt as ApiUrls,Qe as AuthCache,yt as BrowserStoragePersistence,N as Ciphertext,sr as Client,er as Compression,js as ConsentListEntry,Ne as ConversationV1,De as ConversationV2,ht as Conversations,Ue as DecodedMessage,os as EncryptedPersistence,ot as HttpApiClient,ns as InMemoryKeystore,lt as InMemoryPersistence,xt as InvitationV1,ps as KeyGeneratorKeystoreProvider,mt as LocalAuthenticator,_e as MessageV1,Ve as MessageV2,ws as NetworkKeystoreProvider,cs as PrefixedPersistence,Y as PrivateKey,He as PrivateKeyBundleV1,Ge as PrivateKeyBundleV2,oe as PublicKey,de as PublicKeyBundle,Ut as SealedInvitation,te as Signature,ae as SignedPublicKey,ce as SignedPublicKeyBundle,Ns as SnapProvider,et as SortDirection,Ds as StaticKeystoreProvider,ye as Stream,Pe as buildContentTopic,Se as buildDirectMessageTopic,Ae as buildDirectMessageTopicV2,Te as buildUserContactTopic,Ce as buildUserIntroTopic,Ie as buildUserInviteTopic,Be as buildUserPrivateStoreTopic,me as dateToNs,Os as decodeContactBundle,qe as decodeContent,U as decrypt,ar as defaultKeystoreProviders,V as encrypt,F as exportHmacKey,be as fromNanoString,G as generateHmacSignature,L as hkdfHmacKey,$ as importHmacKey,Is as keystoreApiDefs,Ye as mapPaginatedStream,ge as nsToDate,We as retry,Bs as snapKeystoreApiDefs,ve as toNanoString,H as verifyHmacSignature};
//# sourceMappingURL=index.js.map
