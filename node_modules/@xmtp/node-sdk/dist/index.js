import { join } from 'node:path';
import process from 'node:process';
import { GroupUpdatedCodec, ContentTypeGroupUpdated } from '@xmtp/content-type-group-updated';
import { ContentTypeText, TextCodec } from '@xmtp/content-type-text';
import { getInboxIdForAddress as getInboxIdForAddress$1, generateInboxId as generateInboxId$1, createClient } from '@xmtp/node-bindings';
import { ContentTypeId } from '@xmtp/content-type-primitives';

class AsyncStream {
    #done = false;
    #resolveNext;
    #queue;
    stopCallback = undefined;
    constructor() {
        this.#queue = [];
        this.#resolveNext = null;
        this.#done = false;
    }
    get isDone() {
        return this.#done;
    }
    callback = (error, value) => {
        if (error) {
            console.error("stream error", error);
            this.stop(error);
            return;
        }
        if (this.#done) {
            return;
        }
        if (this.#resolveNext) {
            this.#resolveNext({
                done: false,
                error: null,
                value,
            });
            this.#resolveNext = null;
        }
        else {
            this.#queue.push(value);
        }
    };
    stop = (error) => {
        this.#done = true;
        if (this.#resolveNext) {
            this.#resolveNext({
                done: true,
                error: error ?? null,
                value: undefined,
            });
        }
        this.stopCallback?.();
    };
    next = () => {
        if (this.#queue.length > 0) {
            return Promise.resolve({
                done: false,
                error: null,
                value: this.#queue.shift(),
            });
        }
        else if (this.#done) {
            return Promise.resolve({
                done: true,
                error: null,
                value: undefined,
            });
        }
        else {
            return new Promise((resolve) => {
                this.#resolveNext = resolve;
            });
        }
    };
    [Symbol.asyncIterator]() {
        return this;
    }
}

function nsToDate(ns) {
    return new Date(ns / 1_000_000);
}

class DecodedMessage {
    #client;
    content;
    contentType;
    conversationId;
    deliveryStatus;
    fallback;
    compression;
    id;
    kind;
    parameters;
    senderInboxId;
    sentAt;
    sentAtNs;
    constructor(client, message) {
        this.#client = client;
        this.id = message.id;
        this.sentAtNs = message.sentAtNs;
        this.sentAt = nsToDate(message.sentAtNs);
        this.conversationId = message.convoId;
        this.senderInboxId = message.senderInboxId;
        switch (message.kind) {
            case 0 /* NapiGroupMessageKind.Application */:
                this.kind = "application";
                break;
            case 1 /* NapiGroupMessageKind.MembershipChange */:
                this.kind = "membership_change";
                break;
            // no default
        }
        switch (message.deliveryStatus) {
            case 0 /* NapiDeliveryStatus.Unpublished */:
                this.deliveryStatus = "unpublished";
                break;
            case 1 /* NapiDeliveryStatus.Published */:
                this.deliveryStatus = "published";
                break;
            case 2 /* NapiDeliveryStatus.Failed */:
                this.deliveryStatus = "failed";
                break;
            // no default
        }
        this.contentType = message.content.type
            ? new ContentTypeId(message.content.type)
            : undefined;
        this.parameters = message.content.parameters;
        this.fallback = message.content.fallback;
        this.compression = message.content.compression;
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        this.content = this.contentType
            ? this.#client.decodeContent(message, this.contentType)
            : undefined;
    }
}

class Conversation {
    #client;
    #group;
    constructor(client, group) {
        this.#client = client;
        this.#group = group;
    }
    get id() {
        return this.#group.id();
    }
    get name() {
        return this.#group.groupName();
    }
    async updateName(name) {
        return this.#group.updateGroupName(name);
    }
    get imageUrl() {
        return this.#group.groupImageUrlSquare();
    }
    async updateImageUrl(imageUrl) {
        return this.#group.updateGroupImageUrlSquare(imageUrl);
    }
    get description() {
        return this.#group.groupDescription();
    }
    async updateDescription(description) {
        return this.#group.updateGroupDescription(description);
    }
    get pinnedFrameUrl() {
        return this.#group.groupPinnedFrameUrl();
    }
    async updatePinnedFrameUrl(pinnedFrameUrl) {
        return this.#group.updateGroupPinnedFrameUrl(pinnedFrameUrl);
    }
    get isActive() {
        return this.#group.isActive();
    }
    get addedByInboxId() {
        return this.#group.addedByInboxId();
    }
    get createdAtNs() {
        return this.#group.createdAtNs();
    }
    get createdAt() {
        return nsToDate(this.createdAtNs);
    }
    get metadata() {
        const metadata = this.#group.groupMetadata();
        return {
            creatorInboxId: metadata.creatorInboxId(),
            conversationType: metadata.conversationType(),
        };
    }
    async members() {
        return this.#group.listMembers();
    }
    get admins() {
        return this.#group.adminList();
    }
    get superAdmins() {
        return this.#group.superAdminList();
    }
    get permissions() {
        return {
            policyType: this.#group.groupPermissions().policyType(),
            policySet: this.#group.groupPermissions().policySet(),
        };
    }
    isAdmin(inboxId) {
        return this.#group.isAdmin(inboxId);
    }
    isSuperAdmin(inboxId) {
        return this.#group.isSuperAdmin(inboxId);
    }
    async sync() {
        return this.#group.sync();
    }
    stream(callback) {
        const asyncStream = new AsyncStream();
        const stream = this.#group.stream((err, message) => {
            const decodedMessage = new DecodedMessage(this.#client, message);
            asyncStream.callback(err, decodedMessage);
            callback?.(err, decodedMessage);
        });
        asyncStream.stopCallback = stream.end.bind(stream);
        return asyncStream;
    }
    async addMembers(accountAddresses) {
        return this.#group.addMembers(accountAddresses);
    }
    async addMembersByInboxId(inboxIds) {
        return this.#group.addMembersByInboxId(inboxIds);
    }
    async removeMembers(accountAddresses) {
        return this.#group.removeMembers(accountAddresses);
    }
    async removeMembersByInboxId(inboxIds) {
        return this.#group.removeMembersByInboxId(inboxIds);
    }
    async addAdmin(inboxId) {
        return this.#group.addAdmin(inboxId);
    }
    async removeAdmin(inboxId) {
        return this.#group.removeAdmin(inboxId);
    }
    async addSuperAdmin(inboxId) {
        return this.#group.addSuperAdmin(inboxId);
    }
    async removeSuperAdmin(inboxId) {
        return this.#group.removeSuperAdmin(inboxId);
    }
    async publishMessages() {
        return this.#group.publishMessages();
    }
    sendOptimistic(content, contentType) {
        if (typeof content !== "string" && !contentType) {
            throw new Error("Content type is required when sending content other than text");
        }
        const encodedContent = typeof content === "string"
            ? this.#client.encodeContent(content, contentType ?? ContentTypeText)
            : // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this.#client.encodeContent(content, contentType);
        return this.#group.sendOptimistic(encodedContent);
    }
    async send(content, contentType) {
        if (typeof content !== "string" && !contentType) {
            throw new Error("Content type is required when sending content other than text");
        }
        const encodedContent = typeof content === "string"
            ? this.#client.encodeContent(content, contentType ?? ContentTypeText)
            : // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this.#client.encodeContent(content, contentType);
        return this.#group.send(encodedContent);
    }
    messages(options) {
        return (this.#group
            .findMessages(options)
            .map((message) => new DecodedMessage(this.#client, message))
            // filter out messages without content
            .filter((message) => message.content !== undefined));
    }
    get consentState() {
        return this.#group.consentState();
    }
    updateConsentState(consentState) {
        this.#group.updateConsentState(consentState);
    }
    get dmPeerInboxId() {
        return this.#group.dmPeerInboxId();
    }
}

class Conversations {
    #client;
    #conversations;
    constructor(client, conversations) {
        this.#client = client;
        this.#conversations = conversations;
    }
    getConversationById(id) {
        try {
            // findGroupById will throw if group is not found
            const group = this.#conversations.findGroupById(id);
            return new Conversation(this.#client, group);
        }
        catch {
            return null;
        }
    }
    getDmByInboxId(inboxId) {
        try {
            // findDmByTargetInboxId will throw if group is not found
            const group = this.#conversations.findDmByTargetInboxId(inboxId);
            return new Conversation(this.#client, group);
        }
        catch {
            return null;
        }
    }
    getMessageById(id) {
        try {
            // findMessageById will throw if message is not found
            const message = this.#conversations.findMessageById(id);
            return new DecodedMessage(this.#client, message);
        }
        catch {
            return null;
        }
    }
    async newConversation(accountAddresses, options) {
        const group = await this.#conversations.createGroup(accountAddresses, options);
        const conversation = new Conversation(this.#client, group);
        return conversation;
    }
    async newDm(accountAddress) {
        const group = await this.#conversations.createDm(accountAddress);
        const conversation = new Conversation(this.#client, group);
        return conversation;
    }
    async list(options) {
        const groups = await this.#conversations.list(options);
        return groups.map((group) => {
            const conversation = new Conversation(this.#client, group);
            return conversation;
        });
    }
    async listGroups(options) {
        const groups = await this.#conversations.listGroups(options);
        return groups.map((group) => {
            const conversation = new Conversation(this.#client, group);
            return conversation;
        });
    }
    async listDms(options) {
        const groups = await this.#conversations.listDms(options);
        return groups.map((group) => {
            const conversation = new Conversation(this.#client, group);
            return conversation;
        });
    }
    async sync() {
        return this.#conversations.sync();
    }
    stream(callback) {
        const asyncStream = new AsyncStream();
        const stream = this.#conversations.stream((err, group) => {
            const conversation = new Conversation(this.#client, group);
            asyncStream.callback(err, conversation);
            callback?.(err, conversation);
        });
        asyncStream.stopCallback = stream.end.bind(stream);
        return asyncStream;
    }
    streamGroups(callback) {
        const asyncStream = new AsyncStream();
        const stream = this.#conversations.streamGroups((err, group) => {
            const conversation = new Conversation(this.#client, group);
            asyncStream.callback(err, conversation);
            callback?.(err, conversation);
        });
        asyncStream.stopCallback = stream.end.bind(stream);
        return asyncStream;
    }
    streamDms(callback) {
        const asyncStream = new AsyncStream();
        const stream = this.#conversations.streamDms((err, group) => {
            const conversation = new Conversation(this.#client, group);
            asyncStream.callback(err, conversation);
            callback?.(err, conversation);
        });
        asyncStream.stopCallback = stream.end.bind(stream);
        return asyncStream;
    }
    async streamAllMessages(callback) {
        // sync conversations first
        await this.sync();
        const asyncStream = new AsyncStream();
        const stream = this.#conversations.streamAllMessages((err, message) => {
            const decodedMessage = new DecodedMessage(this.#client, message);
            asyncStream.callback(err, decodedMessage);
            callback?.(err, decodedMessage);
        });
        asyncStream.stopCallback = stream.end.bind(stream);
        return asyncStream;
    }
    async streamAllGroupMessages(callback) {
        // sync conversations first
        await this.sync();
        const asyncStream = new AsyncStream();
        const stream = this.#conversations.streamAllGroupMessages((err, message) => {
            const decodedMessage = new DecodedMessage(this.#client, message);
            asyncStream.callback(err, decodedMessage);
            callback?.(err, decodedMessage);
        });
        asyncStream.stopCallback = stream.end.bind(stream);
        return asyncStream;
    }
    async streamAllDmMessages(callback) {
        // sync conversations first
        await this.sync();
        const asyncStream = new AsyncStream();
        const stream = this.#conversations.streamAllDmMessages((err, message) => {
            const decodedMessage = new DecodedMessage(this.#client, message);
            asyncStream.callback(err, decodedMessage);
            callback?.(err, decodedMessage);
        });
        asyncStream.stopCallback = stream.end.bind(stream);
        return asyncStream;
    }
}

const ApiUrls = {
    local: "http://localhost:5556",
    dev: "https://grpc.dev.xmtp.network:443",
    production: "https://grpc.production.xmtp.network:443",
};
class Client {
    #innerClient;
    #conversations;
    #codecs;
    constructor(client, codecs) {
        this.#innerClient = client;
        this.#conversations = new Conversations(this, client.conversations());
        this.#codecs = new Map(codecs.map((codec) => [codec.contentType.toString(), codec]));
    }
    static async create(accountAddress, options) {
        const host = options?.apiUrl ?? ApiUrls[options?.env ?? "dev"];
        const isSecure = host.startsWith("https");
        const dbPath = options?.dbPath ?? join(process.cwd(), `${accountAddress}.db3`);
        const inboxId = (await getInboxIdForAddress$1(host, isSecure, accountAddress)) ||
            generateInboxId$1(accountAddress);
        return new Client(await createClient(host, isSecure, dbPath, inboxId, accountAddress, options?.encryptionKey, options?.requestHistorySync, options?.logging ?? "off"), [new GroupUpdatedCodec(), new TextCodec(), ...(options?.codecs ?? [])]);
    }
    get accountAddress() {
        return this.#innerClient.accountAddress;
    }
    get inboxId() {
        return this.#innerClient.inboxId();
    }
    get installationId() {
        return this.#innerClient.installationId();
    }
    get isRegistered() {
        return this.#innerClient.isRegistered();
    }
    async createInboxSignatureText() {
        try {
            const signatureText = await this.#innerClient.createInboxSignatureText();
            return signatureText;
        }
        catch {
            return null;
        }
    }
    async addWalletSignatureText(existingAccountAddress, newAccountAddress) {
        try {
            const signatureText = await this.#innerClient.addWalletSignatureText(existingAccountAddress, newAccountAddress);
            return signatureText;
        }
        catch {
            return null;
        }
    }
    async revokeWalletSignatureText(accountAddress) {
        try {
            const signatureText = await this.#innerClient.revokeWalletSignatureText(accountAddress);
            return signatureText;
        }
        catch {
            return null;
        }
    }
    async revokeInstallationsSignatureText() {
        try {
            const signatureText = await this.#innerClient.revokeInstallationsSignatureText();
            return signatureText;
        }
        catch {
            return null;
        }
    }
    async canMessage(accountAddresses) {
        return this.#innerClient.canMessage(accountAddresses);
    }
    addSignature(signatureType, signatureBytes) {
        void this.#innerClient.addSignature(signatureType, signatureBytes);
    }
    async applySignatures() {
        return this.#innerClient.applySignatureRequests();
    }
    async registerIdentity() {
        return this.#innerClient.registerIdentity();
    }
    get conversations() {
        return this.#conversations;
    }
    codecFor(contentType) {
        return this.#codecs.get(contentType.toString());
    }
    encodeContent(content, contentType) {
        const codec = this.codecFor(contentType);
        if (!codec) {
            throw new Error(`no codec for ${contentType.toString()}`);
        }
        const encoded = codec.encode(content, this);
        const fallback = codec.fallback(content);
        if (fallback) {
            encoded.fallback = fallback;
        }
        return encoded;
    }
    decodeContent(message, contentType) {
        const codec = this.codecFor(contentType);
        if (!codec) {
            throw new Error(`no codec for ${contentType.toString()}`);
        }
        // throw an error if there's an invalid group membership change message
        if (contentType.sameAs(ContentTypeGroupUpdated) &&
            message.kind !== 1 /* NapiGroupMessageKind.MembershipChange */) {
            throw new Error("Error decoding group membership change");
        }
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return codec.decode(message.content, this);
    }
    async requestHistorySync() {
        return this.#innerClient.requestHistorySync();
    }
    async getInboxIdByAddress(accountAddress) {
        return this.#innerClient.findInboxIdByAddress(accountAddress);
    }
    async inboxState(refreshFromNetwork = false) {
        return this.#innerClient.inboxState(refreshFromNetwork);
    }
    async getLatestInboxState(inboxId) {
        return this.#innerClient.getLatestInboxState(inboxId);
    }
    async inboxStateFromInboxIds(inboxIds, refreshFromNetwork) {
        return this.#innerClient.addressesFromInboxId(refreshFromNetwork ?? false, inboxIds);
    }
    async setConsentStates(consentStates) {
        return this.#innerClient.setConsentStates(consentStates);
    }
    async getConsentState(entityType, entity) {
        return this.#innerClient.getConsentState(entityType, entity);
    }
}

const generateInboxId = (accountAddress) => {
    return generateInboxId$1(accountAddress);
};
const getInboxIdForAddress = async (accountAddress, env = "dev") => {
    const host = ApiUrls[env];
    const isSecure = host.startsWith("https");
    return getInboxIdForAddress$1(host, isSecure, accountAddress);
};

export { ApiUrls, Client, Conversation, Conversations, DecodedMessage, generateInboxId, getInboxIdForAddress };
//# sourceMappingURL=index.js.map
