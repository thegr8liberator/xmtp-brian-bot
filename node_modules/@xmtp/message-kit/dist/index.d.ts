import { Conversation, Client, DecodedMessage, ClientOptions } from '@xmtp/node-sdk';
import { Conversation as Conversation$1, Client as Client$1, DecodedMessage as DecodedMessage$1 } from '@xmtp/xmtp-js';
import { ContentTypeId } from '@xmtp/content-type-primitives';

declare class HandlerContext {
    refConv: Conversation | Conversation$1 | null;
    message: MessageAbstracted;
    group: GroupAbstracted;
    conversation: Conversation$1;
    client: Client;
    version: "v2" | "v3";
    v2client: Client$1;
    skills?: SkillGroup[];
    members?: AbstractedMember[];
    sender?: any;
    getMessageById: (id: string) => DecodedMessage | null;
    private constructor();
    static create(conversation: Conversation | Conversation$1, message: DecodedMessage | DecodedMessage$1 | null, { client, v2client }: {
        client: Client;
        v2client: Client$1;
    }, skillsConfigPath?: string, version?: "v2" | "v3"): Promise<HandlerContext | null>;
    getV2MessageById(reference: string): Promise<DecodedMessage$1 | null>;
    getReplyChain(reference: string, version: "v2" | "v3", botAddress?: string): Promise<{
        chain: Array<{
            address: string;
            content: string;
        }>;
        isSenderInChain: boolean;
    }>;
    reply(message: string): Promise<void>;
    send(message: string): Promise<void>;
    isConversationV2(conversation: Conversation | Conversation$1 | null): conversation is Conversation$1;
    react(emoji: string): Promise<void>;
    getCacheCreationDate(): Promise<Date | undefined>;
    sendTo(message: string, receivers: string[]): Promise<void>;
    skill(text: string, conversation?: Conversation): Promise<void | SkillResponse>;
    findSkill(text: string): SkillCommand | undefined;
    findSkillGroup(content: string): SkillGroup | undefined;
}

type MessageAbstracted = {
    id: string;
    sent: Date;
    content: any;
    version: "v2" | "v3";
    sender: any;
    typeId: string;
};
type GroupAbstracted = {
    id: string;
    sync: () => Promise<void>;
    addMembers: (addresses: string[]) => Promise<void>;
    addMembersByInboxId: (inboxIds: string[]) => Promise<void>;
    send: (content: string, contentType?: ContentTypeId) => Promise<string>;
    isAdmin: (inboxId: string) => boolean;
    isSuperAdmin: (inboxId: string) => boolean;
    createdAt: Date;
};
type SkillResponse = {
    code: number;
    message: string;
    data?: any;
};
type SkillHandler = (context: HandlerContext) => Promise<void | SkillResponse>;
type Handler = (context: HandlerContext) => Promise<void>;
type Config = {
    client?: ClientOptions;
    privateKey?: string;
    experimental?: boolean;
    skillsConfigPath?: string;
    hideInitLogMessage?: boolean;
    attachments?: boolean;
    memberChange?: boolean;
};
interface SkillParamConfig {
    default?: string | number | boolean;
    type: "number" | "string" | "username" | "quoted" | "address" | "prompt" | "url";
    plural?: boolean;
    values?: string[];
}
interface SkillGroup {
    name: string;
    image?: boolean;
    description: string;
    tag?: string;
    tagHandler?: SkillHandler;
    skills: SkillCommand[];
}
interface SkillCommand {
    command: string;
    handler?: SkillHandler;
    triggers: string[];
    adminOnly?: boolean;
    description: string;
    examples?: string[];
    params: Record<string, SkillParamConfig>;
}
interface AbstractedMember {
    inboxId: string;
    address: string;
    accountAddresses: string[];
    installationIds?: string[];
}
type MetadataValue = string | number | boolean;
type Metadata = Record<string, MetadataValue | MetadataValue[]>;

declare function run(handler: Handler, config?: Config): Promise<void>;

declare function xmtpClient(config?: Config): Promise<{
    client: Client;
    v2client: Client$1;
}>;

export { type AbstractedMember, type Config, type GroupAbstracted, type Handler, HandlerContext, type MessageAbstracted, type Metadata, type MetadataValue, type SkillCommand, type SkillGroup, type SkillHandler, type SkillParamConfig, type SkillResponse, run, xmtpClient };
