import 'dotenv/config';
import { Conversation, Client as Client$1 } from '@xmtp/node-sdk';
import fs$1 from 'fs/promises';
import path from 'path';
import { ContentTypeText, TextCodec } from '@xmtp/content-type-text';
import { ContentTypeReply, ReplyCodec } from '@xmtp/content-type-reply';
import { ContentTypeRemoteAttachment, RemoteAttachmentCodec, AttachmentCodec } from '@xmtp/content-type-remote-attachment';
import { ContentTypeReaction, ReactionCodec } from '@xmtp/content-type-reaction';
import { Client } from '@xmtp/xmtp-js';
import * as fs from 'fs';
import { createWalletClient, http, toBytes } from 'viem';
import { privateKeyToAccount } from 'viem/accounts';
import { mainnet } from 'viem/chains';
import { GrpcApiClient } from '@xmtp/grpc-api-client';

function extractCommandValues(text, skills) {
    if (!text.startsWith("/"))
        return { command: undefined, params: {} };
    const defaultResult = {
        command: undefined,
        params: {},
    };
    try {
        if (typeof text !== "string")
            return defaultResult;
        // Replace all "â€œ" and "â€" with "'" and '"'
        text = text.toLowerCase().replaceAll("â€œ", '"').replaceAll("â€", '"');
        const parts = text.match(/[^\s"']+|"([^"]*)"|'([^']*)'|`([^`]*)`/g);
        if (!parts)
            return defaultResult;
        let commandName = parts[0].startsWith("/") ? parts[0].slice(1) : parts[0];
        let commandConfig = undefined;
        for (const group of skills) {
            commandConfig = group.skills.find((cmd) => cmd.command.startsWith(`/${commandName}`));
            if (commandConfig)
                break;
        }
        if (!commandConfig)
            return defaultResult;
        const values = {
            command: commandName,
            params: {},
        };
        const expectedParams = commandConfig.params || {};
        const usedIndices = new Set();
        for (const [param, paramConfig] of Object.entries(expectedParams)) {
            const { type, values: possibleValues = [], plural = false, default: defaultValue, } = paramConfig;
            let valueFound = false;
            // Handle string type with no possible values
            if (type === "string" && possibleValues.length === 0) {
                const stringIndex = parts.findIndex((part, idx) => !usedIndices.has(idx) && idx > 0);
                if (stringIndex !== -1) {
                    values.params[param] = parts[stringIndex];
                    usedIndices.add(stringIndex);
                    valueFound = true;
                }
            }
            else if (type === "quoted") {
                const quotedIndex = parts.findIndex((part, idx) => /^["'`].*["'`]$/.test(part) && !usedIndices.has(idx));
                if (quotedIndex !== -1) {
                    values.params[param] = parts[quotedIndex].slice(1, -1);
                    usedIndices.add(quotedIndex);
                    valueFound = true;
                }
            }
            else if (type === "url") {
                const urlIndex = parts.findIndex((part, idx) => /^https?:\/\//.test(part) && !usedIndices.has(idx));
                if (urlIndex !== -1) {
                    values.params[param] = parts[urlIndex];
                    usedIndices.add(urlIndex);
                    valueFound = true;
                }
            }
            else if (type === "prompt") {
                values.params[param] = parts.slice(1).join(" ");
                valueFound = true;
            }
            else if (type === "username") {
                // Updated regular expression to ensure usernames start with @
                const usernameParts = parts.reduce((acc, part, idx) => {
                    if (!usedIndices.has(idx) &&
                        (/^@[a-zA-Z][a-zA-Z0-9_-]*$/.test(part) ||
                            /^[a-zA-Z0-9-]+\.eth$/.test(part)) // Ensure it starts with @ or is a .eth domain
                    ) {
                        usedIndices.add(idx);
                        // Handle potential comma-separated values
                        const usernames = part.split(",");
                        acc.push(...usernames);
                    }
                    return acc;
                }, []);
                if (usernameParts.length > 0) {
                    values.params[param] = plural ? usernameParts : usernameParts[0];
                    valueFound = true;
                }
            }
            else if (type === "address") {
                // Handle comma-separated addresses
                const addressParts = parts.reduce((acc, part, idx) => {
                    if (!usedIndices.has(idx) && /^0x[a-fA-F0-9]{40}$/.test(part)) {
                        usedIndices.add(idx);
                        const addresses = part.split(",").map((a) => a.trim());
                        acc.push(...addresses);
                    }
                    return acc;
                }, []);
                if (addressParts.length > 0) {
                    values.params[param] =
                        addressParts.length === 1 ? addressParts[0] : addressParts;
                    valueFound = true;
                }
            }
            else if (type === "number") {
                // Handle comma-separated numbers
                const numberParts = parts.reduce((acc, part, idx) => {
                    if (!usedIndices.has(idx) && !isNaN(parseFloat(part))) {
                        usedIndices.add(idx);
                        const numbers = part
                            .split(",")
                            .map((n) => parseFloat(n.trim()))
                            .filter((n) => !isNaN(n));
                        acc.push(...numbers);
                    }
                    return acc;
                }, []);
                if (numberParts.length > 0) {
                    //@ts-ignore
                    values.params[param] =
                        numberParts.length === 1 ? numberParts[0] : numberParts;
                    valueFound = true;
                }
            }
            else if (possibleValues.length > 0) {
                const index = parts.findIndex((part, idx) => possibleValues.includes(part.toLowerCase()) &&
                    !usedIndices.has(idx));
                if (index !== -1) {
                    values.params[param] = parts[index];
                    usedIndices.add(index);
                    valueFound = true;
                }
            }
            // If no value was found, set the default value if it exists
            if (!valueFound && defaultValue !== undefined) {
                //@ts-ignore
                values.params[param] = defaultValue;
            }
        }
        return values;
    }
    catch (e) {
        console.error(e);
        return defaultResult;
    }
}
async function loadSkillsFile(configPath = "skills.js") {
    const resolvedPath = path.resolve(process.cwd(), "dist/" + configPath);
    let skills = [];
    try {
        const module = await import(resolvedPath);
        skills = module?.skills;
    }
    catch (error) {
        if (process.env.MSG_LOG === "true")
            console.error(`Error loading command config from ${resolvedPath}:`);
    }
    if (skills === undefined || skills?.length === 0)
        return [];
    return skills;
}
const shorterLogMessage = (message) => {
    return message?.substring(0, 60) + (message?.length > 60 ? "..." : "");
};
const logMessage = (message) => {
    if (process.env.MSG_LOG === "false")
        return;
    console.log(shorterLogMessage(message));
};
async function logInitMessage(client, config) {
    const coolLogo = `\x1b[38;2;250;105;119m\
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â• â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â•šâ•â•â–ˆâ–ˆâ•”â•â•â•
â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   
â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•  â•šâ•â•â•â•â–ˆâ–ˆâ•‘â•šâ•â•â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   
â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   
â•šâ•â•     â•šâ•â•â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â• â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•â•šâ•â•   â•šâ•â•   
Powered by XMTP \x1b[0m`;
    console.log(coolLogo);
    console.log(`
    Send a message to this account on Converse:                              
    ðŸ”— https://converse.xyz/dm/${client.accountAddress}`);
    const skills = await loadSkillsFile();
    if (config?.experimental ||
        config?.attachments ||
        config?.memberChange ||
        skills?.length === 0) {
        console.warn(`\x1b[33m
    Warnings:`);
        if (config?.attachments) {
            console.warn("\t- âš ï¸ Attachments are enabled");
        }
        if (config?.client?.logging) {
            console.warn(`\t- âš ï¸ Logging is set to ${config.client.logging}`);
        }
        if (config?.privateKey) {
            console.warn("\t- âš ï¸ Private key is set from the code");
        }
        if (config?.memberChange) {
            console.warn("\t- âš ï¸ Member changes are enabled");
        }
        if (config?.skillsConfigPath) {
            console.warn(`\t- âš ï¸ Skills config path is set to ${config.skillsConfigPath}`);
        }
        if (skills === undefined || skills?.length === 0) {
            console.warn("\t- âš ï¸ No skills.ts file found or wrongly formatted");
        }
        if (config?.experimental) {
            console.warn(`\t- â˜£ï¸ EXPERIMENTAL MODE ENABLED:
        \t\tâš ï¸ All group messages will be exposed â€” proceed with caution.
        \t\tâ„¹ Guidelines: https://messagekit.ephemerahq.com/guidelines`);
        }
    }
    console.log(`â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Logging new messages to console â†´`);
}

class HandlerContext {
    refConv = null;
    message;
    group;
    conversation;
    client;
    version;
    v2client;
    skills;
    members;
    sender;
    getMessageById;
    constructor(conversation, { client, v2client }) {
        this.client = client;
        this.v2client = v2client;
        if (conversation instanceof Conversation) {
            this.group = {
                id: conversation.id,
                sync: conversation.sync.bind(conversation),
                addMembers: conversation.addMembers.bind(conversation),
                send: conversation.send.bind(conversation),
                createdAt: conversation.createdAt,
                addMembersByInboxId: conversation.addMembersByInboxId.bind(conversation),
                isAdmin: () => false,
                isSuperAdmin: () => false,
            };
            this.version = "v3";
        }
        else {
            this.version = "v2";
            this.conversation = conversation;
        }
    }
    static async create(conversation, message, { client, v2client }, skillsConfigPath, version) {
        const context = new HandlerContext(conversation, { client, v2client });
        if (message && message.id) {
            //v2
            const sentAt = "sentAt" in message ? message.sentAt : message.sent;
            let members;
            if (version === "v2") {
                context.sender = {
                    address: message.senderAddress,
                    inboxId: message.senderAddress,
                    installationIds: [],
                    accountAddresses: [message.senderAddress],
                };
            }
            else {
                members = await conversation.members();
                context.members = members.map((member) => ({
                    inboxId: member.inboxId,
                    address: member.accountAddresses[0],
                    accountAddresses: member.accountAddresses,
                    installationIds: member.installationIds,
                }));
                let MemberSender = members?.find((member) => member.inboxId === message.senderInboxId);
                context.sender = {
                    address: MemberSender?.accountAddresses[0],
                    inboxId: MemberSender?.inboxId,
                    installationIds: [],
                    accountAddresses: MemberSender?.accountAddresses,
                };
            }
            //commands
            context.skills = await loadSkillsFile(skillsConfigPath);
            context.getMessageById =
                client.conversations?.getMessageById?.bind(client.conversations) ||
                    (() => null);
            // **Correct Binding:**
            context.getReplyChain = context.getReplyChain.bind(context);
            context.skill = context.skill.bind(context);
            //trim spaces from text
            let content = typeof message.content === "string"
                ? { content: message.content.trim(), ...message.contentType }
                : message.content;
            if (message?.contentType?.sameAs(ContentTypeText)) {
                const extractedValues = extractCommandValues(content.content, context.skills);
                if (extractedValues) {
                    content = {
                        ...content,
                        ...extractedValues,
                    };
                }
            }
            else if (message?.contentType?.sameAs(ContentTypeReply)) {
                content = {
                    ...content,
                    typeId: message.content.contentType.typeId,
                };
            }
            else if (message?.contentType?.sameAs(ContentTypeRemoteAttachment)) {
                const attachment = await RemoteAttachmentCodec.load(content, client);
                content = {
                    ...content,
                    ...message.contentType,
                    attachment: attachment,
                };
            }
            context.message = {
                id: message.id,
                content: content,
                sender: context.sender,
                typeId: message.contentType?.typeId,
                sent: sentAt,
                version: version ?? "v2",
            };
            return context;
        }
        return null;
    }
    async getV2MessageById(reference) {
        const conversations = await this.v2client.conversations.list();
        for (const conversation of conversations) {
            const messages = await conversation.messages();
            if (messages.find((m) => m.id === reference)) {
                return messages.find((m) => m.id === reference);
            }
        }
        return null;
    }
    async getReplyChain(reference, version, botAddress) {
        let msg = null;
        let senderAddress = "";
        if (version === "v3")
            msg = await this.getMessageById(reference);
        else if (version === "v2")
            msg = await this.getV2MessageById(reference);
        if (!msg) {
            return {
                chain: [],
                isSenderInChain: false,
            };
        }
        let sender = (await this.group.members())?.find((member) => member.inboxId === msg.senderInboxId ||
            member.accountAddresses.includes(msg.senderAddress));
        senderAddress = sender?.accountAddresses[0] ?? "";
        let content = msg?.content?.content ?? msg?.content;
        let isSenderBot = senderAddress.toLowerCase() === botAddress?.toLowerCase();
        let chain = [{ address: senderAddress, content: content }];
        if (msg?.content?.reference) {
            const { chain: replyChain, isSenderInChain } = await this.getReplyChain(msg.content.reference, version, botAddress);
            chain = replyChain;
            isSenderBot = isSenderBot || isSenderInChain;
            chain.push({
                address: senderAddress,
                content: content,
            });
        }
        return {
            chain: chain,
            isSenderInChain: isSenderBot,
        };
    }
    async reply(message) {
        const reply = {
            content: message,
            contentType: ContentTypeText,
            reference: this.message.id,
        };
        const conversation = this.refConv || this.conversation || this.group;
        if (conversation) {
            if (this.isConversationV2(conversation)) {
                await conversation.send(reply, { contentType: ContentTypeReply });
                logMessage("sent: " + reply.content);
            }
            else {
                await conversation.send(reply, ContentTypeReply);
                logMessage("sent: " + reply.content);
            }
        }
    }
    async send(message) {
        const conversation = this.refConv || this.conversation || this.group;
        if (conversation) {
            await conversation.send(message);
            logMessage("sent: " + message);
        }
    }
    isConversationV2(conversation) {
        return conversation?.topic !== undefined;
    }
    async react(emoji) {
        const reaction = {
            action: "added",
            schema: "unicode",
            reference: this.message.id,
            content: emoji,
        };
        const conversation = this.refConv || this.conversation || this.group;
        if (conversation) {
            if (this.isConversationV2(conversation)) {
                await conversation.send(reaction, { contentType: ContentTypeReaction });
            }
            else if (conversation instanceof Conversation) {
                await conversation.send(reaction, ContentTypeReaction);
            }
        }
    }
    async getCacheCreationDate() {
        //Gets the creation date of the cache folder
        //Could be used to check if the cache is outdated
        //Generally indicates the deployment date of the bot
        try {
            const stats = await fs$1.stat(".data");
            const cacheCreationDate = new Date(stats.birthtime);
            return cacheCreationDate;
        }
        catch (err) {
            console.error(err);
        }
    }
    async sendTo(message, receivers) {
        const conversations = await this.v2client.conversations.list();
        //Sends a 1 to 1 to multiple users
        for (const receiver of receivers) {
            if (this.v2client.address.toLowerCase() === receiver.toLowerCase()) {
                continue;
            }
            let targetConversation = conversations.find((conv) => conv.peerAddress.toLowerCase() === receiver.toLowerCase());
            if (!targetConversation) {
                targetConversation =
                    await this.v2client.conversations.newConversation(receiver);
            }
            // Send the message only once per receiver
            await targetConversation.send(message);
            logMessage("sent: " + message);
        }
    }
    async skill(text, conversation) {
        //if (process.env.MSG_LOG) console.log("skill", text);
        if (conversation)
            this.refConv = conversation;
        try {
            let skillCommand = this.findSkill(text);
            const extractedValues = extractCommandValues(text, this.skills ?? []);
            if ((text.startsWith("/") || text.startsWith("@")) && !extractedValues) {
                console.warn("Command not valid", text);
            }
            else if (skillCommand) {
                // Mock context for command execution
                const mockContext = {
                    ...this,
                    conversation: conversation ?? this.conversation,
                    message: {
                        ...this.message,
                        content: {
                            ...this.message.content,
                            ...extractedValues,
                        },
                    },
                    skill: this.skill.bind(this),
                    reply: this.reply.bind(this),
                    send: this.send.bind(this),
                    sendTo: this.sendTo.bind(this),
                    react: this.react.bind(this),
                    getMessageById: this.getMessageById.bind(this),
                    getReplyChain: this.getReplyChain.bind(this),
                };
                this.refConv = null;
                return skillCommand?.handler?.(mockContext);
            }
            else if (text.startsWith("/") || text.startsWith("@")) {
                console.warn("Command not valid", text);
            }
            else
                return this.send(text);
        }
        catch (e) {
            console.log("error", e);
        }
        finally {
            this.refConv = null;
        }
    }
    findSkill(text) {
        let skills = this.skills ?? [];
        const trigger = text?.split(" ")[0].toLowerCase();
        for (const skillGroup of skills) {
            const handler = skillGroup.skills.find((skill) => {
                return skill?.triggers?.includes(trigger);
            });
            if (handler !== undefined)
                return handler;
        }
        return undefined;
    }
    findSkillGroup(content) {
        let skills = this.skills ?? [];
        return skills.find((skill) => {
            if (skill.tag && content.includes(`${skill.tag}`)) {
                return true;
            }
            return undefined;
        });
    }
}

async function xmtpClient(config) {
    // Check if both clientConfig and privateKey are empty
    let key = config?.privateKey ?? process.env.KEY;
    let user = createUser(key);
    let env = process.env.XMTP_ENV;
    if (!env) {
        env = "production";
    }
    if (!fs.existsSync(`.data`)) {
        fs.mkdirSync(`.data`);
    }
    const defaultConfig = {
        env: env,
        dbPath: `.data/${user.account?.address}-${env}`,
        codecs: [
            new TextCodec(),
            new ReactionCodec(),
            new ReplyCodec(),
            new RemoteAttachmentCodec(),
            new AttachmentCodec(),
        ],
    };
    // Merge the default configuration with the provided config. Repeated fields in clientConfig will override the default values
    const finalConfig = { ...defaultConfig, ...config?.client };
    //v2
    const account2 = privateKeyToAccount(key);
    const wallet2 = createWalletClient({
        account: account2,
        chain: mainnet,
        transport: http(),
    });
    const v2client = await Client.create(wallet2, {
        ...finalConfig,
        apiUrl: undefined,
        skipContactPublishing: false,
        apiClientFactory: GrpcApiClient.fromOptions,
    });
    const client = await Client$1.create(user.account.address, finalConfig);
    if (!config?.hideInitLogMessage)
        logInitMessage(client, config);
    if (!client.isRegistered) {
        const signature = await getSignature(client, user);
        if (signature) {
            client.addSignature(1, signature);
        }
        await client.registerIdentity();
    }
    return { client, v2client };
}
const createUser = (key) => {
    const account = privateKeyToAccount(key);
    return {
        key,
        account,
        wallet: createWalletClient({
            account,
            chain: mainnet,
            transport: http(),
        }),
    };
};
const getSignature = async (client, user) => {
    const signatureText = await client.createInboxSignatureText();
    if (signatureText) {
        const signature = await user.wallet.signMessage({
            message: signatureText,
        });
        return toBytes(signature);
    }
    return null;
};

async function run(handler, config) {
    const { client, v2client } = await xmtpClient(config);
    const { inboxId: address } = client;
    const { address: addressV2 } = v2client;
    // sync and list conversations
    await client.conversations.sync();
    await client.conversations.list();
    const handleMessage = async (version, message) => {
        const conversation = await getConversation(message, version);
        if (message && conversation) {
            try {
                const { senderInboxId, kind } = message;
                const senderAddress = message.senderAddress;
                if (
                //If same address do nothin
                senderAddress?.toLowerCase() === addressV2?.toLowerCase() ||
                    //If same address do nothin
                    // Filter out membership_change messages
                    (senderInboxId?.toLowerCase() === address?.toLowerCase() &&
                        kind !== "membership_change")) {
                    return;
                }
                const context = await HandlerContext.create(conversation, message, { client, v2client }, config?.skillsConfigPath, version);
                if (!context) {
                    if (process.env.MSG_LOG === "true")
                        console.warn("No context found", message);
                    return;
                }
                // Check if the message content triggers a command
                const { isMessageValid, customHandler } = commandTriggered(context);
                if (isMessageValid && customHandler)
                    await customHandler(context);
                else if (isMessageValid)
                    await handler(context);
            }
            catch (e) {
                console.log(`error`, e);
            }
        }
    };
    const commandTriggered = (context) => {
        const { message: { content: { content }, typeId, sender, }, version, client, v2client, group, } = context;
        let skillCommand = context.findSkill(content);
        const { inboxId: senderInboxId } = client;
        const { address: senderAddress } = v2client;
        const isSameAddress = sender.address?.toLowerCase() === senderAddress?.toLowerCase() ||
            (sender.inboxId?.toLowerCase() === senderInboxId.toLowerCase() &&
                typeId !== "group_updated");
        const isCommandTriggered = skillCommand?.command;
        const isExperimental = config?.experimental ?? false;
        const isAddedMemberOrPass = typeId === "group_updated" &&
            config?.memberChange &&
            content?.addedInboxes?.length === 0
            ? false
            : true;
        const isRemoteAttachment = typeId == "remoteStaticAttachment";
        const isAdminOrPass = skillCommand?.adminOnly &&
            group &&
            !group?.isAdmin(sender.inboxId) &&
            !group?.isSuperAdmin(sender.inboxId)
            ? false
            : true;
        // Remote attachments work if image:true in runner config
        // Replies only work with explicit mentions from triggers.
        // Text only works with explicit mentions from triggers.
        // Reactions dont work with triggers.
        const isImageValid = isRemoteAttachment && config?.attachments;
        const acceptedType = ["text", "remoteStaticAttachment", "reply"].includes(typeId ?? "");
        const skillGroup = context.findSkillGroup(content); // Check if the message content triggers a tag
        const isTagged = group && skillGroup ? true : false;
        const isMessageValid = isSameAddress
            ? false
            : // v2 only accepts text, remoteStaticAttachment, reply
                version == "v2" && acceptedType
                    ? true
                    : //If its image is also good, if it has a command image:true
                        isImageValid
                            ? true
                            : //If its not an admin, nope
                                !isAdminOrPass
                                    ? false
                                    : isExperimental
                                        ? true
                                        : //If its a group update but its not an added member, nope
                                            !isAddedMemberOrPass
                                                ? false
                                                : //If it has a command trigger, good
                                                    isCommandTriggered
                                                        ? true
                                                        : //If it has a tag trigger, good
                                                            isTagged
                                                                ? true
                                                                : false;
        if (process.env.MSG_LOG === "true") {
            console.log("isMessageValid", {
                isSameAddress,
                content,
                version,
                typeId,
                acceptedType,
                isRemoteAttachment,
                isImageValid,
                isAdminOrPass,
                isExperimental,
                isAddedMemberOrPass,
                skillsParsed: context.skills?.length,
                isTagged: isTagged
                    ? {
                        tag: skillGroup?.tag,
                        tagHandler: skillGroup?.tagHandler !== undefined,
                    }
                    : false,
                isCommandTriggered: isCommandTriggered
                    ? {
                        command: skillCommand?.command,
                        examples: skillCommand?.examples,
                        description: skillCommand?.description,
                        params: skillCommand?.params
                            ? Object.entries(skillCommand.params).map(([key, value]) => ({
                                key,
                                value,
                            }))
                            : undefined,
                    }
                    : false,
                isMessageValid,
            });
        }
        if (isMessageValid)
            logMessage(`msg_${version}: ` + (typeId == "text" ? content : typeId));
        return {
            isMessageValid,
            customHandler: skillCommand
                ? skillCommand.handler
                : skillGroup
                    ? skillGroup.tagHandler
                    : undefined,
        };
    };
    const getConversation = async (message, version) => {
        return version === "v3"
            ? await client.conversations.getConversationById(message?.conversationId ?? "")
            : message?.conversation;
    };
    const STREAM_LOG = process.env.STREAM_LOG === "true";
    // ... existing code ...
    async function streamMessages(version) {
        const clientToUse = version === "v3" ? client : v2client;
        let retryCount = 0;
        const MAX_RETRY_DELAY = 5000; // max 5 seconds
        while (true) {
            try {
                if (STREAM_LOG) {
                    console.log(`[${version}] Attempting to start client stream... (Attempt ${retryCount + 1})`);
                }
                const stream = await clientToUse.conversations.streamAllMessages();
                if (STREAM_LOG) {
                    console.log(`[${version}] Successfully reconnected after ${retryCount} retries.`);
                }
                retryCount = 0;
                for await (const message of stream) {
                    await handleMessage(version, message);
                }
            }
            catch (streamError) {
                if (STREAM_LOG) {
                    console.warn(`[${version}] Stream error occurred:`, streamError?.code || streamError);
                    console.warn(`[${version}] Attempting to reconnect...`);
                }
                retryCount++;
                const delay = Math.min(MAX_RETRY_DELAY * Math.pow(1.5, retryCount - 1), 30000);
                if (STREAM_LOG) {
                    console.error(`[${version}] Connection error (${streamError?.code || "UNKNOWN"}). ` +
                        `Retry ${retryCount} - Reconnecting in ${delay / 1000} seconds...`);
                }
                await new Promise((resolve) => setTimeout(resolve, delay));
            }
        }
    }
    // Run both clients' streams concurrently
    await Promise.all([streamMessages("v2"), streamMessages("v3")]);
}

export { HandlerContext, run, xmtpClient };
//# sourceMappingURL=index.js.map
