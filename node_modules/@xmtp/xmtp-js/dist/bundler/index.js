import{ciphertext as e,privateKey as t,signature as s,publicKey as r,fetcher as n,keystore as i,message as a,content as o,authn as c,messageApi as d,invitation as h,privatePreferences as y,contact as u}from"@xmtp/proto";import l from"long";import*as p from"@noble/secp256k1";import{bytesToHex as w,keccak256 as f,getAddress as m,hexToSignature as g,hexToBytes as v,hashMessage as b,verifyMessage as E}from"viem";import{ContentTypeText as K,TextCodec as k}from"@xmtp/content-type-text";import{ContentTypeId as P}from"@xmtp/content-type-primitives";import{Mutex as S}from"async-mutex";import A from"elliptic";import{user_preferences_encrypt as T,user_preferences_decrypt as C,generate_private_preferences_topic as I}from"@xmtp/user-preferences-bindings-wasm/bundler";import{createConsentMessage as B}from"@xmtp/consent-proof-signature";class R{constructor(e){if(!e.aes256GcmHkdfSha256)throw new Error("invalid ciphertext");if(e.aes256GcmHkdfSha256.payload.length<16)throw new Error(`invalid ciphertext ciphertext length: ${e.aes256GcmHkdfSha256.payload.length}`);if(32!==e.aes256GcmHkdfSha256.hkdfSalt.length)throw new Error(`invalid ciphertext salt length: ${e.aes256GcmHkdfSha256.hkdfSalt.length}`);if(12!==e.aes256GcmHkdfSha256.gcmNonce.length)throw new Error(`invalid ciphertext nonce length: ${e.aes256GcmHkdfSha256.gcmNonce.length}`);this.aes256GcmHkdfSha256=e.aes256GcmHkdfSha256}toBytes(){return e.Ciphertext.encode(this).finish()}static fromBytes(t){return new R(e.Ciphertext.decode(t))}}const N=window.crypto,D=(new Uint8Array).buffer,M=(new Uint8Array).buffer;async function x(e){return new Uint8Array(await N.subtle.digest("SHA-256",e))}async function _(e,t,s){const r=N.getRandomValues(new Uint8Array(32)),n=N.getRandomValues(new Uint8Array(12)),i=await O(t,r),a=await N.subtle.encrypt(U(n,s),i,e);return new R({aes256GcmHkdfSha256:{payload:new Uint8Array(a),hkdfSalt:r,gcmNonce:n}})}async function V(e,t,s){if(!e.aes256GcmHkdfSha256)throw new Error("invalid payload ciphertext");const r=await O(t,e.aes256GcmHkdfSha256.hkdfSalt),n=await N.subtle.decrypt(U(e.aes256GcmHkdfSha256.gcmNonce,s),r,e.aes256GcmHkdfSha256.payload);return new Uint8Array(n)}function U(e,t){const s={name:"AES-GCM",iv:e};return t&&(s.additionalData=t),s}async function O(e,t){const s=await N.subtle.importKey("raw",e,"HKDF",!1,["deriveKey"]);return N.subtle.deriveKey({name:"HKDF",hash:"SHA-256",salt:t,info:D},s,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}async function q(e,t){const s=await N.subtle.importKey("raw",e,"HKDF",!1,["deriveKey"]);return N.subtle.deriveKey({name:"HKDF",hash:"SHA-256",salt:M,info:t},s,{name:"HMAC",hash:"SHA-256",length:256},!0,["sign","verify"])}async function L(e,t,s){const r=await q(e,t),n=await N.subtle.sign("HMAC",r,s);return new Uint8Array(n)}async function G(e,t,s){return await N.subtle.verify("HMAC",e,t,s)}async function H(e){const t=await N.subtle.exportKey("raw",e);return new Uint8Array(t)}async function F(e){return N.subtle.importKey("raw",e,{name:"HMAC",hash:"SHA-256",length:256},!0,["sign","verify"])}const $=p.utils.bytesToHex;function j(e,t){if(e.length!==t.length)return!1;for(let s=0;s<e.length;s++)if(e[s]!==t[s])return!1;return!0}function X(e){const t=g(e),s=v(t.r),r=v(t.s);let n=Number(t.v);0!==n&&1!==n||(n+=27);const i=1-n%2,a=new Uint8Array(64);return a.set(s),a.set(r,s.length),{bytes:a,recovery:i}}function J(e){if(32!==e.bytes.length)throw new Error(`invalid private key length: ${e.bytes.length}`)}class z{constructor(e){if(!e.secp256k1)throw new Error("invalid private key");if(J(e.secp256k1),this.secp256k1=e.secp256k1,this.createdNs=e.createdNs,!e.publicKey)throw new Error("missing public key");this.publicKey=new ie(e.publicKey)}static async generate(e){const t={bytes:p.utils.randomPrivateKey()},s=l.fromNumber((new Date).getTime()).mul(1e6),r=new ne({secp256k1Uncompressed:{bytes:p.getPublicKey(t.bytes)},createdNs:s}),n=await e.signKey(r);return new z({secp256k1:t,createdNs:s,publicKey:n})}generated(){return new Date(this.createdNs.div(1e6).toNumber())}async sign(e){const[t,s]=await p.sign(e,this.secp256k1.bytes,{recovered:!0,der:!1});return new ee({ecdsaCompact:{bytes:t,recovery:s}})}async signKey(e){const t=e.toBytes(),s=await x(t),r=await this.sign(s);return new ie({keyBytes:t,signature:r})}static async signerKey(e,t){return Z(await x(e.bytesToSign()),t)}sharedSecret(e){return p.getSharedSecret(this.secp256k1.bytes,e.secp256k1Uncompressed.bytes,!1)}encrypt(e,t,s){return _(e,this.sharedSecret(t),s)}decrypt(e,t,s){return V(e,this.sharedSecret(t),s)}matches(e){return this.publicKey.equals(e)}equals(e){return j(this.secp256k1.bytes,e.secp256k1.bytes)&&this.publicKey.equals(e.publicKey)}toBytes(){return t.SignedPrivateKey.encode(this).finish()}validatePublicKey(){return j(p.getPublicKey(this.secp256k1.bytes),this.publicKey.secp256k1Uncompressed.bytes)}static fromBytes(e){return new z(t.SignedPrivateKey.decode(e))}static fromLegacyKey(e,t){return new z({createdNs:e.timestamp.mul(1e6),secp256k1:e.secp256k1,publicKey:ie.fromLegacyKey(e.publicKey,t)})}}class W{constructor(e){if(!e.secp256k1)throw new Error("invalid private key");if(J(e.secp256k1),this.timestamp=e.timestamp,this.secp256k1=e.secp256k1,!e.publicKey)throw new Error("missing public key");this.publicKey=new ae(e.publicKey)}static generate(){const e={bytes:p.utils.randomPrivateKey()},t=l.fromNumber((new Date).getTime());return new W({secp256k1:e,timestamp:t,publicKey:new ae({secp256k1Uncompressed:{bytes:p.getPublicKey(e.bytes)},timestamp:t})})}generated(){return new Date(this.timestamp.toNumber())}async sign(e){const[t,s]=await p.sign(e,this.secp256k1.bytes,{recovered:!0,der:!1});return new ee({ecdsaCompact:{bytes:t,recovery:s}})}async signKey(e){const t=await x(e.bytesToSign());return e.signature=await this.sign(t),e}sharedSecret(e){return p.getSharedSecret(this.secp256k1.bytes,e.secp256k1Uncompressed.bytes,!1)}encrypt(e,t,s){return _(e,this.sharedSecret(t),s)}decrypt(e,t,s){return V(e,this.sharedSecret(t),s)}matches(e){return this.publicKey.equals(e)}validatePublicKey(){return j(p.getPublicKey(this.secp256k1.bytes),this.publicKey.secp256k1Uncompressed.bytes)}toBytes(){return t.PrivateKey.encode(this).finish()}static fromBytes(e){return new W(t.PrivateKey.decode(e))}}function Y(e){if(64!==e.bytes.length)throw new Error(`invalid signature length: ${e.bytes.length}`);if(0!==e.recovery&&1!==e.recovery)throw new Error(`invalid recovery bit: ${e.recovery}`)}function Q(e,t){return e.recovery===t.recovery&&j(e.bytes,t.bytes)}function Z(e,t){const s=p.recoverPublicKey(e,t.bytes,t.recovery);return s?new ne({secp256k1Uncompressed:{bytes:s},createdNs:l.fromNumber(0)}):void 0}class ee{constructor(e){if(e.ecdsaCompact)Y(e.ecdsaCompact),this.ecdsaCompact=e.ecdsaCompact;else{if(!e.walletEcdsaCompact)throw new Error("invalid signature");Y(e.walletEcdsaCompact),this.walletEcdsaCompact=e.walletEcdsaCompact}}async signerKey(e){return this.ecdsaCompact?z.signerKey(e,this.ecdsaCompact):this.walletEcdsaCompact?se.signerKey(e,this.walletEcdsaCompact):void 0}getPublicKey(e){let t;if(this.ecdsaCompact)t=p.recoverPublicKey(e,this.ecdsaCompact.bytes,this.ecdsaCompact.recovery);else{if(!this.walletEcdsaCompact)throw new Error("invalid v1 signature");t=p.recoverPublicKey(e,this.walletEcdsaCompact.bytes,this.walletEcdsaCompact.recovery)}return t?new ae({secp256k1Uncompressed:{bytes:t},timestamp:l.fromNumber(0)}):void 0}equals(e){return this.ecdsaCompact&&e.ecdsaCompact?Q(this.ecdsaCompact,e.ecdsaCompact):!(!this.walletEcdsaCompact||!e.walletEcdsaCompact)&&Q(this.walletEcdsaCompact,e.walletEcdsaCompact)}toBytes(){return s.Signature.encode(this).finish()}static fromBytes(e){return new ee(s.Signature.decode(e))}}var te;!function(e){e[e.INBOX_KEY=0]="INBOX_KEY",e[e.SEND_KEY=1]="SEND_KEY"}(te||(te={}));class se{constructor(e){this.wallet=e}static identitySigRequestText(e){return`XMTP : Create Identity\n${$(e)}\n\nFor more info: https://xmtp.org/signatures/`}static signerKey(e,t){return Z(v(b(this.identitySigRequestText(e.bytesToSign()))),t)}async signKey(e){const t=e.toBytes(),s=await this.wallet.signMessage(se.identitySigRequestText(t)),{bytes:r,recovery:n}=X(s),i=new ee({walletEcdsaCompact:{bytes:r,recovery:n}});return new ie({keyBytes:t,signature:i})}}const re=new l(10**9).mul(10**9);class ne{constructor(e){if(!e?.secp256k1Uncompressed)throw new Error("invalid public key");!function(e){if(65!==e.bytes.length)throw new Error(`invalid public key length: ${e.bytes.length}`);if(4!==e.bytes[0])throw new Error(`unrecognized public key prefix: ${e.bytes[0]}`)}(e.secp256k1Uncompressed),this.secp256k1Uncompressed=e.secp256k1Uncompressed,this.createdNs=e.createdNs.toUnsigned()}generated(){return new Date(this.timestamp.toNumber())}isFromLegacyKey(){return this.createdNs.lessThan(re)}get timestamp(){return(this.isFromLegacyKey()?this.createdNs:this.createdNs.div(1e6)).toUnsigned()}verify(e,t){return!!e.ecdsaCompact&&p.verify(e.ecdsaCompact.bytes,t,this.secp256k1Uncompressed.bytes)}async verifyKey(e){if(!e.signature)return!1;const t=await x(e.bytesToSign());return this.verify(e.signature,t)}equals(e){return j(this.secp256k1Uncompressed.bytes,e.secp256k1Uncompressed.bytes)}getEthereumAddress(){return function(e){const t=w(e.slice(1)),s=f(t),r=s.substring(s.length-40);return m(`0x${r}`)}(this.secp256k1Uncompressed.bytes)}toBytes(){return r.UnsignedPublicKey.encode(this).finish()}static fromBytes(e){return new ne(r.UnsignedPublicKey.decode(e))}}class ie extends ne{constructor(e){if(!e.keyBytes)throw new Error("missing key bytes");if(super(r.UnsignedPublicKey.decode(e.keyBytes)),this.keyBytes=e.keyBytes,!e.signature)throw new Error("missing key signature");this.signature=new ee(e.signature)}get unsignedKey(){return new ne({createdNs:this.createdNs,secp256k1Uncompressed:this.secp256k1Uncompressed})}signerKey(){return this.signature.signerKey(this)}async walletSignatureAddress(){if(!this.signature.walletEcdsaCompact)throw new Error("key was not signed by a wallet");const e=await this.signerKey();if(!e)throw new Error("key signature not valid");return e.getEthereumAddress()}equals(e){return this.unsignedKey.equals(e.unsignedKey)&&this.signature.equals(e.signature)}bytesToSign(){return this.keyBytes}toBytes(){return r.SignedPublicKey.encode(this).finish()}static fromBytes(e){return new ie(r.SignedPublicKey.decode(e))}toLegacyKey(){if(!this.isFromLegacyKey())throw new Error("cannot be converted to legacy key");let e=this.signature;return e.walletEcdsaCompact&&(e=new ee({ecdsaCompact:e.walletEcdsaCompact})),new ae({timestamp:this.timestamp,secp256k1Uncompressed:this.secp256k1Uncompressed,signature:e})}static fromLegacyKey(e,t){if(!e.signature)throw new Error("key is not signed");let s=e.signature;return t&&(s=new ee({walletEcdsaCompact:s.ecdsaCompact})),new ie({keyBytes:e.bytesToSign(),signature:s})}}class ae extends ne{constructor(e){super({createdNs:e.timestamp.mul(1e6),secp256k1Uncompressed:e.secp256k1Uncompressed}),e.signature&&(!e.signature.ecdsaCompact&&e.signature.walletEcdsaCompact?this.signature=new ee({ecdsaCompact:{bytes:e.signature.walletEcdsaCompact.bytes,recovery:e.signature.walletEcdsaCompact.recovery}}):this.signature=new ee(e.signature))}get timestamp(){return this.createdNs.div(1e6)}bytesToSign(){return r.PublicKey.encode({timestamp:this.timestamp,secp256k1Uncompressed:this.secp256k1Uncompressed}).finish()}async signWithWallet(e){const t=await e.signMessage(se.identitySigRequestText(this.bytesToSign())),{bytes:s,recovery:r}=X(t);this.signature=new ee({ecdsaCompact:{bytes:s,recovery:r}})}walletSignatureAddress(){if(!this.signature)throw new Error("key is not signed");const e=v(b(se.identitySigRequestText(this.bytesToSign()))),t=this.signature.getPublicKey(e);if(!t)throw new Error("key signature is malformed");return t.getEthereumAddress()}toBytes(){return r.PublicKey.encode(this).finish()}static fromBytes(e){return new ae(r.PublicKey.decode(e))}}class oe{constructor(e){if(!e.identityKey)throw new Error("missing identity key");if(!e.preKey)throw new Error("missing pre-key");this.identityKey=new ie(e.identityKey),this.preKey=new ie(e.preKey)}walletSignatureAddress(){return this.identityKey.walletSignatureAddress()}equals(e){return this.identityKey.equals(e.identityKey)&&this.preKey.equals(e.preKey)}toBytes(){return r.SignedPublicKeyBundle.encode(this).finish()}isFromLegacyBundle(){return this.identityKey.isFromLegacyKey()&&this.preKey.isFromLegacyKey()}toLegacyBundle(){return new ce({identityKey:this.identityKey.toLegacyKey(),preKey:this.preKey.toLegacyKey()})}static fromBytes(e){const t=r.SignedPublicKeyBundle.decode(e);return new oe(t)}static fromLegacyBundle(e){return new oe({identityKey:ie.fromLegacyKey(e.identityKey,!0),preKey:ie.fromLegacyKey(e.preKey)})}}class ce{constructor(e){if(!e.identityKey)throw new Error("missing identity key");if(!e.preKey)throw new Error("missing pre-key");this.identityKey=new ae(e.identityKey),this.preKey=new ae(e.preKey)}equals(e){return this.identityKey.equals(e.identityKey)&&this.preKey.equals(e.preKey)}walletSignatureAddress(){return this.identityKey.walletSignatureAddress()}toBytes(){return r.PublicKeyBundle.encode(this).finish()}static fromBytes(e){const t=r.PublicKeyBundle.decode(e);return new ce(t)}}class de{constructor(e,t){this.messageEnvelope=e,this.onSend=t}async messageID(){if(!this.messageEnvelope.message)throw new Error("no envelope message");return $(await x(this.messageEnvelope.message))}async send(){return this.onSend()}}class he{constructor(e,t,s,r,n){this.messages=[],this.resolvers=[],this.topics=t,this.client=e,this.callback=this.newMessageCallback(s,r),this.onConnectionLost=n}newMessageCallback(e,t){return async s=>{if(s.message)try{const r=await e(s);if(!r)return;if(t){const e=t(r);e&&this.resubscribeToTopics(e)}const n=this.resolvers.pop();n?n({value:r}):this.messages.unshift(r)}catch(e){console.warn(e)}}}async start(){if(!this.callback)throw new Error("Missing callback for stream");this.subscriptionManager=this.client.apiClient.subscribe({contentTopics:this.topics},(async e=>{this.callback&&await(this?.callback(e))}),this.onConnectionLost)}static async create(e,t,s,r,n){const i=new he(e,t,s,r,n);return await i.start(),i}[Symbol.asyncIterator](){return this}async return(){return this.subscriptionManager&&await this.subscriptionManager.unsubscribe(),this.callback?(this.callback=void 0,this.resolvers.forEach((e=>e({value:void 0,done:!0}))),{value:void 0,done:!0}):{value:void 0,done:!0}}next(){const e=this.messages.pop();return e?Promise.resolve({value:e}):this.callback?new Promise((e=>this.resolvers.unshift(e))):Promise.resolve({value:void 0,done:!0})}async resubscribeToTopics(e){if(!this.callback||!this.subscriptionManager)throw new Error("Missing callback for stream");if("function"==typeof this.subscriptionManager?.updateContentTopics)return this.subscriptionManager.updateContentTopics(e);await this.subscriptionManager.unsubscribe(),this.topics=e,this.subscriptionManager=this.client.apiClient.subscribe({contentTopics:this.topics},(async e=>{this.callback&&await(this?.callback(e))}),this.onConnectionLost)}}const{b64Decode:ye,b64Encode:ue}=n;function le(e,t){const s=new Uint8Array(e.length+t.length);return s.set(e),s.set(t,e.length),s}function pe(e){const t=new ArrayBuffer(4);return new DataView(t).setInt32(0,e,!0),new Uint8Array(t)}function we(e){const t=e.buffer;return new DataView(t).getInt32(0,!0)}function fe(e){return l.fromNumber(e.valueOf()).multiply(1e6)}function me(e){return new Date(e.divide(1e6).toNumber())}const ge=e=>e&&fe(e).toString(),ve=e=>{if(e)return me(l.fromString(e))};class be extends Error{constructor(e,t){super(t),this.code=e}}const Ee=e=>{if(e.error)throw new be(e.error.code,e.error.message);if(!e.result)throw new be(i.ErrorCode.ERROR_CODE_UNSPECIFIED,"No result from Keystore");if("encrypted"in e.result&&!e.result.encrypted)throw new Error("Missing ciphertext");if("decrypted"in e.result&&!e.result.decrypted)throw new Error("Missing decrypted result");return e.result},Ke=(e,t)=>({requests:e.map((e=>{const s=new ce({identityKey:e.header.sender?.identityKey,preKey:e.header.sender?.preKey}),r=t.equals(s);return{payload:e.ciphertext,peerKeys:r?new ce({identityKey:e.header.recipient?.identityKey,preKey:e.header.recipient?.preKey}):s,headerBytes:e.headerBytes,isSender:r}}))}),ke=e=>`/xmtp/0/${e}/proto`,Pe=(e,t)=>{const s=[m(e),m(t)];return s.sort(),ke(`dm-${s.join("-")}`)},Se=e=>ke(`m-${e}`),Ae=e=>ke(`contact-${m(e)}`),Te=e=>ke(`intro-${m(e)}`),Ce=e=>ke(`invite-${m(e)}`),Ie=e=>ke(`privatestore-${e}`),Be=e=>{const t=/^[\x21-\x7F]+$/,s=e.indexOf("0/");if(-1!==s){const r=e.substring(s+2,e.lastIndexOf("/proto"));return t.test(r)}return!1};class Re{constructor(e,t,s){this.conversationVersion="v1",this.context=void 0,this.peerAddress=m(t),this.client=e,this.createdAt=s}get clientAddress(){return this.client.address}async allow(){await this.client.contacts.allow([this.peerAddress])}async deny(){await this.client.contacts.deny([this.peerAddress])}get isAllowed(){return this.client.contacts.isAllowed(this.peerAddress)}get isDenied(){return this.client.contacts.isDenied(this.peerAddress)}get consentState(){return this.client.contacts.consentState(this.peerAddress)}get topic(){return Pe(this.peerAddress,this.client.address)}get ephemeralTopic(){return Pe(this.peerAddress,this.client.address).replace("/xmtp/0/dm-","/xmtp/0/dmE-")}async messages(e){const t=Pe(this.peerAddress,this.client.address),s=await this.client.listEnvelopes(t,this.processEnvelope.bind(this),e);return this.decryptBatch(s,t,!1)}messagesPaginated(e){return this.client.listEnvelopesPaginated(this.topic,this.decodeMessage.bind(this),e)}async decodeMessage(e){if(!e.contentTopic)throw new Error("Missing content topic");const t=await this.processEnvelope(e),s=await this.decryptBatch([t],e.contentTopic,!0);if(!s.length)throw new Error("No results");return s[0]}async prepareMessage(e,t){let s,r=await this.client.getUserContact(this.peerAddress);if(!r)throw new Error(`recipient ${this.peerAddress} is not registered`);r instanceof ce||(r=r.toLegacyBundle());const n=t?.ephemeral?this.ephemeralTopic:this.topic;this.client.contacts.addresses.has(this.peerAddress)?s=[n]:(s=[Te(this.peerAddress),Te(this.client.address),n],this.client.contacts.addresses.add(this.peerAddress));const{payload:i}=await this.client.encodeContent(e,t),a=await this.createMessage(i,r,t?.timestamp),o=a.toBytes(),c={contentTopic:n,message:o,timestampNs:ge(a.sent)};return new de(c,(async()=>(await this.client.publishEnvelopes(s.map((e=>({contentTopic:e,message:o,timestamp:a.sent})))),Ve.fromV1Message(a,e,t?.contentType||K,i,n,this))))}streamMessages(e){return he.create(this.client,[this.topic],(async e=>this.decodeMessage(e)),void 0,e)}async processEnvelope({message:e,contentTopic:t}){if(!e||!e.length)throw new Error("empty envelope");const s=await xe.fromBytes(e),{senderAddress:r,recipientAddress:n}=s;if(!r||!n||!t||Pe(r,n)!==this.topic)throw new Error("Headers do not match intended recipient");return s}streamEphemeral(e){return he.create(this.client,[this.ephemeralTopic],this.decodeMessage.bind(this),void 0,e)}async send(e,t){let s,r=await this.client.getUserContact(this.peerAddress);if(!r)throw new Error(`recipient ${this.peerAddress} is not registered`);r instanceof ce||(r=r.toLegacyBundle());const n=t?.ephemeral?this.ephemeralTopic:this.topic;this.client.contacts.addresses.has(this.peerAddress)?s=[n]:(s=[Te(this.peerAddress),Te(this.client.address),n],this.client.contacts.addresses.add(this.peerAddress));const i=t?.contentType||K,{payload:a}=await this.client.encodeContent(e,t),o=await this.createMessage(a,r,t?.timestamp);return await this.client.publishEnvelopes(s.map((e=>({contentTopic:e,message:o.toBytes(),timestamp:o.sent})))),"unknown"===this.consentState&&await this.allow(),Ve.fromV1Message(o,e,i,a,n,this)}async decryptBatch(e,t,s=!1){const r=(await this.client.keystore.decryptV1(Ke(e,this.client.publicKeyBundle))).responses,n=[];for(let i=0;i<r.length;i++){const a=r[i],o=e[i];try{const{decrypted:e}=Ee(a);n.push(await this.buildDecodedMessage(o,e,t))}catch(e){if(s)throw e;console.warn("Error decoding content",e)}}return n}async buildDecodedMessage(e,t,s){const{content:r,contentType:n,error:i,contentFallback:a}=await this.client.decodeContent(t);return Ve.fromV1Message(e,r,n,t,s,this,i,a)}async createMessage(e,t,s){return s=s||new Date,xe.encode(this.client.keystore,e,this.client.publicKeyBundle,t,s)}}class Ne{constructor(e,t,s,r,n,i){this.conversationVersion="v2",this.topic=t,this.createdAt=r,this.context=n,this.client=e,this.peerAddress=s,this.consentProof=i}get clientAddress(){return this.client.address}async allow(){await this.client.contacts.allow([this.peerAddress])}async deny(){await this.client.contacts.deny([this.peerAddress])}get isAllowed(){return this.client.contacts.isAllowed(this.peerAddress)}get isDenied(){return this.client.contacts.isDenied(this.peerAddress)}get consentState(){return this.client.contacts.consentState(this.peerAddress)}get consentProofPayload(){return this.consentProof}async messages(e){const t=await this.client.listEnvelopes(this.topic,this.processEnvelope.bind(this),e);return this.decryptBatch(t,!1)}messagesPaginated(e){return this.client.listEnvelopesPaginated(this.topic,this.decodeMessage.bind(this),e)}get ephemeralTopic(){return this.topic.replace("/xmtp/0/m","/xmtp/0/mE")}streamEphemeral(e){return he.create(this.client,[this.ephemeralTopic],this.decodeMessage.bind(this),void 0,e)}streamMessages(e){return he.create(this.client,[this.topic],this.decodeMessage.bind(this),void 0,e)}async send(e,t){const{payload:s,shouldPush:r}=await this.client.encodeContent(e,t),n=await this.createMessage(s,r,t?.timestamp),i=t?.ephemeral?this.ephemeralTopic:this.topic;await this.client.publishEnvelopes([{contentTopic:i,message:n.toBytes(),timestamp:n.sent}]);const a=t?.contentType||K;return"unknown"===this.consentState&&await this.allow(),Ve.fromV2Message(n,e,a,i,s,this,this.client.address)}async createMessage(e,t,s){const r={topic:this.topic,createdNs:fe(s||new Date)},n=a.MessageHeaderV2.encode(r).finish(),i=await x(le(n,e)),c={payload:e,sender:this.client.signedPublicKeyBundle,signature:await this.client.keystore.signDigest({digest:i,prekeyIndex:0,identityKey:void 0})},d=o.SignedContent.encode(c).finish(),{encrypted:h,senderHmac:y}=await this.encryptMessage(d,n),u={v1:void 0,v2:{headerBytes:n,ciphertext:h,senderHmac:y,shouldPush:t}},l=a.Message.encode(u).finish();return _e.create(u,r,l,y,t)}async decryptBatch(e,t=!1){const s=(await this.client.keystore.decryptV2(this.buildDecryptRequest(e))).responses,r=[];for(let n=0;n<s.length;n++){const i=s[n],a=e[n];try{const{decrypted:e}=Ee(i);r.push(await this.buildDecodedMessage(a,e))}catch(e){if(t)throw e;console.warn("Error decoding content",e)}}return r}buildDecryptRequest(e){return{requests:e.map((e=>({payload:e.ciphertext,headerBytes:e.headerBytes,contentTopic:this.topic})))}}async encryptMessage(e,t){const{responses:s}=await this.client.keystore.encryptV2({requests:[{payload:e,headerBytes:t,contentTopic:this.topic}]});if(1!==s.length)throw new Error("Invalid response length");const{encrypted:r,senderHmac:n}=Ee(s[0]);return{encrypted:r,senderHmac:n}}async buildDecodedMessage(e,t){const s=o.SignedContent.decode(t);if(!s.sender?.identityKey||!s.sender?.preKey||!s.signature)throw new Error("incomplete signed content");await async function(e){const t=e.sender?.preKey;if(!t||!t.signature||!t.keyBytes)throw new Error("missing pre-key or pre-key signature");const s=e.sender?.identityKey;if(!s)throw new Error("missing identity key in bundle");if(!await new ie(s).verifyKey(new ie(t)))throw new Error("pre key not signed by identity key")}(s);const r=await x(le(e.headerBytes,s.payload));if(!new ie(s.sender?.preKey).verify(new ee(s.signature),r))throw new Error("invalid signature");const n=await new oe(s.sender).walletSignatureAddress(),{content:i,contentType:a,error:c,contentFallback:d}=await this.client.decodeContent(s.payload);return Ve.fromV2Message(e,i,a,this.topic,s.payload,this,n,c,d)}async prepareMessage(e,t){const{payload:s,shouldPush:r}=await this.client.encodeContent(e,t),n=await this.createMessage(s,r,t?.timestamp),i=n.toBytes(),a=t?.ephemeral?this.ephemeralTopic:this.topic,o={contentTopic:a,message:i,timestampNs:ge(n.sent)};return new de(o,(async()=>(await this.client.publishEnvelopes([{contentTopic:a,message:i,timestamp:n.sent}]),Ve.fromV2Message(n,e,t?.contentType||K,a,s,this,this.client.address))))}async processEnvelope(e){if(!e.message||!e.contentTopic)throw new Error("empty envelope");const t=a.Message.decode(e.message);if(!t.v2)throw new Error("unknown message version");const s=a.MessageHeaderV2.decode(t.v2.headerBytes);if(s.topic!==this.topic)throw new Error("topic mismatch");return _e.create(t,s,e.message,t.v2.senderHmac,t.v2.shouldPush)}async decodeMessage(e){if(!e.contentTopic)throw new Error("Missing content topic");const t=await this.processEnvelope(e),s=await this.decryptBatch([t],!0);if(!s.length)throw new Error("No results");return s[0]}}const De=e=>{if(e.v1?.ciphertext)return[e.v1.headerBytes,new R(e.v1.ciphertext)];if(e.v2?.ciphertext)return[e.v2.headerBytes,new R(e.v2.ciphertext)];throw new Error("unknown message version")};class Me{constructor(e,t,s){[this.headerBytes,this.ciphertext]=De(s),this.id=e,this.bytes=t}toBytes(){return this.bytes}}class xe extends Me{constructor(e,t,s,r,n){super(e,t,s),this.conversation=void 0,this.senderAddress=n,this.header=r}static async create(e,t,s){if(!t.sender)throw new Error("missing message sender");const r=new ce(t.sender).walletSignatureAddress(),n=$(await x(s));return new xe(n,s,e,t,r)}get sent(){return new Date(this.header.timestamp.toNumber())}get recipientAddress(){if(this.header?.recipient?.identityKey)return new ae(this.header.recipient.identityKey).walletSignatureAddress()}async decrypt(e,t){const s=(await e.decryptV1(Ke([this],t))).responses;if(!s.length)throw new Error("No response from Keystore");const{decrypted:r}=Ee(s[0]);return r}static fromBytes(e){const t=a.Message.decode(e),[s]=De(t),r=a.MessageHeaderV1.decode(s);if(!r)throw new Error("missing message header");if(!r.sender)throw new Error("missing message sender");if(!r.sender.identityKey)throw new Error("missing message sender identity key");if(!r.sender.preKey)throw new Error("missing message sender pre-key");if(!r.recipient)throw new Error("missing message recipient");if(!r.recipient.identityKey)throw new Error("missing message recipient identity-key");if(!r.recipient.preKey)throw new Error("missing message recipient pre-key");return xe.create(t,r,e)}static async encode(e,t,s,r,n){const i={sender:s,recipient:r,timestamp:l.fromNumber(n.getTime())},o=a.MessageHeaderV1.encode(i).finish(),c=await e.encryptV1({requests:[{recipient:r,headerBytes:o,payload:t}]});if(!c.responses.length)throw new Error("No response from Keystore");const{encrypted:d}=Ee(c.responses[0]),h={v1:{headerBytes:o,ciphertext:d},v2:void 0},y=a.Message.encode(h).finish();return xe.create(h,i,y)}}class _e extends Me{constructor(e,t,s,r,n,i){super(e,t,s),this.header=r,this.senderHmac=n,this.shouldPush=i}static async create(e,t,s,r,n){const i=$(await x(s));return new _e(i,s,e,t,r,n)}get sent(){return me(this.header.createdNs)}}class Ve{constructor({id:e,messageVersion:t,senderAddress:s,recipientAddress:r,conversation:n,contentBytes:i,contentType:a,contentTopic:o,content:c,sent:d,error:h,contentFallback:y}){this.id=e,this.messageVersion=t,this.senderAddress=s,this.recipientAddress=r,this.conversation=n,this.contentType=a,this.sent=d,this.error=h,this.content=c,this.contentTopic=o,this.contentBytes=i,this.contentFallback=y}toBytes(){return a.DecodedMessage.encode({...this,conversation:{topic:this.conversation.topic,context:this.conversation.context??void 0,createdNs:fe(this.conversation.createdAt),peerAddress:this.conversation.peerAddress,consentProofPayload:this.conversation.consentProof??void 0},sentNs:fe(this.sent)}).finish()}static async fromBytes(e,t){const s=a.DecodedMessage.decode(e),r=s.messageVersion;if("v1"!==r&&"v2"!==r)throw new Error("Invalid message version");if(!s.conversation)throw new Error("No conversation reference found");const{content:n,contentType:i,error:o,contentFallback:c}=await t.decodeContent(s.contentBytes);return new Ve({...s,content:n,contentType:i,error:o,messageVersion:r,sent:me(s.sentNs),conversation:Ue(s.conversation,t,r),contentFallback:c})}static fromV1Message(e,t,s,r,n,i,a,o){const{id:c,senderAddress:d,recipientAddress:h,sent:y}=e;if(!d)throw new Error("Sender address is required");return new Ve({id:c,messageVersion:"v1",senderAddress:d,recipientAddress:h,sent:y,content:t,contentBytes:r,contentType:s,contentTopic:n,conversation:i,error:a,contentFallback:o})}static fromV2Message(e,t,s,r,n,i,a,o,c){const{id:d,sent:h}=e;return new Ve({id:d,messageVersion:"v2",senderAddress:a,sent:h,content:t,contentBytes:n,contentType:s,contentTopic:r,conversation:i,error:o,contentFallback:c})}}function Ue(e,t,s){if("v1"===s)return new Re(t,e.peerAddress,me(e.createdNs));if("v2"===s)return new Ne(t,e.topic,e.peerAddress,me(e.createdNs),e.context,e.consentProofPayload);throw new Error(`Unknown conversation version ${s}`)}function Oe(e,t){return t.decodeContent(e)}class qe extends Error{constructor(e){super(`no pre-key matches: ${$(e.secp256k1Uncompressed.bytes)}`)}}class Le{constructor(e){if(this.version=2,!e.identityKey)throw new Error("missing identity key");this.identityKey=new z(e.identityKey),this.preKeys=(e.preKeys||[]).map((e=>new z(e)))}static async generate(e){const t=await z.generate(new se(e)),s=new Le({identityKey:t,preKeys:[]});return await s.addPreKey(),s}getCurrentPreKey(){return this.preKeys[0]}findPreKey(e){const t=this.preKeys.find((t=>t.matches(e)));if(!t)throw new qe(e);return t}async addPreKey(){this._publicKeyBundle=void 0;const e=await z.generate(this.identityKey);this.preKeys.unshift(e)}getPublicKeyBundle(){return this._publicKeyBundle||(this._publicKeyBundle=new oe({identityKey:this.identityKey.publicKey,preKey:this.getCurrentPreKey().publicKey})),this._publicKeyBundle}async sharedSecret(e,t,s){if(!e.identityKey||!e.preKey)throw new Error("invalid peer key bundle");if(!await e.identityKey.verifyKey(e.preKey))throw new Error("peer preKey signature invalid");if(!this.identityKey)throw new Error("missing identity key");let r,n,i;s?(i=this.findPreKey(t),r=i.sharedSecret(e.identityKey),n=this.identityKey.sharedSecret(e.preKey)):(i=this.findPreKey(t),r=this.identityKey.sharedSecret(e.preKey),n=i.sharedSecret(e.identityKey));const a=i.sharedSecret(e.preKey),o=new Uint8Array(r.length+n.length+a.length);return o.set(r,0),o.set(n,r.length),o.set(a,r.length+n.length),o}encode(){return t.PrivateKeyBundle.encode({v1:void 0,v2:this}).finish()}validatePublicKeys(){return!!this.identityKey.validatePublicKey()&&this.preKeys.every((e=>e.validatePublicKey()))}equals(e){if(this.preKeys.length!==e.preKeys.length)return!1;for(let t=0;t<this.preKeys.length;t++)if(!this.preKeys[t].equals(e.preKeys[t]))return!1;return this.identityKey.equals(e.identityKey)}static fromLegacyBundle(e){return new Le({identityKey:z.fromLegacyKey(e.identityKey,!0),preKeys:e.preKeys.map((e=>z.fromLegacyKey(e)))})}}class Ge{constructor(e){if(this.version=1,!e.identityKey)throw new Error("missing identity key");this.identityKey=new W(e.identityKey),this.preKeys=(e.preKeys||[]).map((e=>new W(e)))}static async generate(e){const t=W.generate();e&&await t.publicKey.signWithWallet(e);const s=new Ge({identityKey:t,preKeys:[]});return await s.addPreKey(),s}getCurrentPreKey(){return this.preKeys[0]}findPreKey(e){const t=this.preKeys.find((t=>t.matches(e)));if(!t)throw new qe(e);return t}async addPreKey(){this._publicKeyBundle=void 0;const e=W.generate();await this.identityKey.signKey(e.publicKey),this.preKeys.unshift(e)}getPublicKeyBundle(){return this._publicKeyBundle||(this._publicKeyBundle=new ce({identityKey:this.identityKey.publicKey,preKey:this.getCurrentPreKey().publicKey})),this._publicKeyBundle}validatePublicKeys(){return!!this.identityKey.validatePublicKey()&&this.preKeys.every((e=>e.validatePublicKey()))}async sharedSecret(e,t,s){if(!e.identityKey||!e.preKey)throw new Error("invalid peer key bundle");if(!await e.identityKey.verifyKey(e.preKey))throw new Error("peer preKey signature invalid");if(!this.identityKey)throw new Error("missing identity key");let r,n,i;s?(i=this.findPreKey(t),r=i.sharedSecret(e.identityKey),n=this.identityKey.sharedSecret(e.preKey)):(i=this.findPreKey(t),r=this.identityKey.sharedSecret(e.preKey),n=i.sharedSecret(e.identityKey));const a=i.sharedSecret(e.preKey),o=new Uint8Array(r.length+n.length+a.length);return o.set(r,0),o.set(n,r.length),o.set(a,r.length+n.length),o}encode(){return t.PrivateKeyBundle.encode({v1:this,v2:void 0}).finish()}}function He(e){const s=t.PrivateKeyBundle.decode(e);if(s.v1)return new Ge(s.v1);if(s.v2)return new Le(s.v2);throw new Error("unknown private key bundle version")}class Fe{constructor({walletAddr:e,createdNs:t}){this.walletAddr=e,this.createdNs=t}static create(e,t){return t=t||new Date,new Fe({walletAddr:e,createdNs:fe(t)})}static fromBytes(e){const t=c.AuthData.decode(e);return new Fe(t)}toBytes(){return c.AuthData.encode(this).finish()}}class $e{constructor({identityKey:e,authDataBytes:t,authDataSignature:s}){if(!e)throw new Error("Missing identity key in token");if(!s)throw new Error("Missing authDataSignature in token");this.identityKey=e,this.authDataBytes=t,this.authDataSignature=s}get authData(){return this._authData||(this._authData=Fe.fromBytes(this.authDataBytes)),this._authData}get ageMs(){return(new Date).valueOf()-this.authData.createdNs.div(1e6).toNumber()}toBytes(){return c.Token.encode(this).finish()}static fromBytes(e){return new $e(c.Token.decode(e))}toBase64(){return Buffer.from(this.toBytes()).toString("base64")}}class je{constructor(e){this.keystore=e}async createToken(e){return(e=>e instanceof $e?e:new $e(e))(await this.keystore.createAuthToken({timestampNs:e?fe(e):void 0}))}}const Xe=e=>new Promise((t=>setTimeout(t,e))),Je=e=>!!e;async function ze(e,t,s,r,n=Je,i=1){const a="number"==typeof i?i:1;try{return await e(...t)}catch(i){if(!n(i)||a>s)throw i;return await Xe(r),ze(e,t,s,r,n,a+1)}}async function*We(e,t){for await(const s of e){const e=await Promise.allSettled(s.map(t)),r=[];for(const t of e)"fulfilled"===t.status?r.push(t.value):console.warn("Failed to process envelope due to reason: ",t.reason);yield r}}class Ye{constructor(e,t=3590){this.authenticator=e,this.maxAgeMs=1e3*t}async getToken(){return(!this.token||this.token.ageMs>this.maxAgeMs)&&await this.refresh(),this.token.toBase64()}async refresh(){this.token=await this.authenticator.createToken()}}const{MessageApi:Qe,SortDirection:Ze}=d,et={local:"http://localhost:5555",dev:"https://dev.xmtp.network",production:"https://production.xmtp.network"};var tt;!function(e){e[e.OK=0]="OK",e[e.CANCELLED=1]="CANCELLED",e[e.UNKNOWN=2]="UNKNOWN",e[e.INVALID_ARGUMENT=3]="INVALID_ARGUMENT",e[e.DEADLINE_EXCEEDED=4]="DEADLINE_EXCEEDED",e[e.NOT_FOUND=5]="NOT_FOUND",e[e.ALREADY_EXISTS=6]="ALREADY_EXISTS",e[e.PERMISSION_DENIED=7]="PERMISSION_DENIED",e[e.RESOURCE_EXHAUSTED=8]="RESOURCE_EXHAUSTED",e[e.FAILED_PRECONDITION=9]="FAILED_PRECONDITION",e[e.ABORTED=10]="ABORTED",e[e.OUT_OF_RANGE=11]="OUT_OF_RANGE",e[e.UNIMPLEMENTED=12]="UNIMPLEMENTED",e[e.INTERNAL=13]="INTERNAL",e[e.UNAVAILABLE=14]="UNAVAILABLE",e[e.DATA_LOSS=15]="DATA_LOSS",e[e.UNAUTHENTICATED=16]="UNAUTHENTICATED"}(tt||(tt={}));class st extends Error{constructor(e,t){super(e),this.code=t}static fromObject(e){return new st(e.message,e.code)}}const rt=e=>!!e&&!("AbortError"!==e.name&&!e.message.includes("aborted")),nt=e=>!(e=>!(!e||!("code"in e)||16!==e.code))(e),it=e=>e.message&&e.message.length?("string"==typeof e.message&&(e.message=ye(e.message)),e):e;class at{constructor(e,t){this.pathPrefix=e,this.maxRetries=t?.maxRetries||5,this.appVersion=t?.appVersion,this.version="xmtp-js/13.0.3",e===et.dev&&console.info("\nXX    XX MM    MM TTTTTT PPPPPP   DDDDD   EEEEEEE VV     VV \n XX  XX  MMM  MMM   TT   PP   PP  DD  DD  EE      VV     VV \n  XXXX   MM MM MM   TT   PPPPPP   DD   DD EEEEE    VV   VV  \n XX  XX  MM    MM   TT   PP       DD   DD EE        VV VV   \nXX    XX MM    MM   TT   PP       DDDDDD  EEEEEEE    VVV    \n\nConnected to the XMTP 'dev' network. Use 'production' for production messages.\nhttps://github.com/xmtp/xmtp-js#xmtp-production-and-dev-network-environments\n")}async _query(e){try{return await ze(Qe.Query,[e,{pathPrefix:this.pathPrefix,mode:"cors",headers:this.headers()}],this.maxRetries,100)}catch(e){throw st.fromObject(e)}}_batchQuery(e){return ze(Qe.BatchQuery,[e,{pathPrefix:this.pathPrefix,mode:"cors",headers:this.headers()}],this.maxRetries,100)}async _publish(e,t=0){const s=await this.getToken(),r=this.headers();r.set("Authorization",`Bearer ${s}`);try{return await ze(Qe.Publish,[e,{pathPrefix:this.pathPrefix,mode:"cors",headers:r}],this.maxRetries,100,nt)}catch(s){if(nt(s)||t>=1)throw st.fromObject(s);return await(this.authCache?.refresh()),this._publish(e,t+1)}}_subscribe(e,t,s){const r=new AbortController;return(async()=>{for(;;){const n=(new Date).getTime();try{if(await Qe.Subscribe(e,t,{pathPrefix:this.pathPrefix,signal:r.signal,mode:"cors",headers:this.headers()}),r.signal.aborted)return;console.info("Stream connection closed. Resubscribing"),(new Date).getTime()-n<1e3&&await Xe(1e3),s?.()}catch(e){if(rt(e)||r.signal.aborted)return;console.info("Stream connection closed. Resubscribing"),(new Date).getTime()-n<1e3&&await Xe(1e3),s?.()}}})(),{unsubscribe:async()=>{r?.abort()}}}async query(e,{direction:t=Ze.SORT_DIRECTION_ASCENDING,limit:s,pageSize:r}){const n=[],i=e.contentTopic.startsWith("userpreferences-")?500:100;for await(const a of this.queryIteratePages(e,{direction:t,pageSize:r?Math.min(r,i):i}))for(const e of a)if(n.push(e),s&&n.length===s)return n;return n}async*queryIterator(e,t){for await(const s of this.queryIteratePages(e,t))for(const e of s)yield e}async*queryIteratePages({contentTopic:e,startTime:t,endTime:s},{direction:r,pageSize:n=10}){if(!e||!e.length)throw new Error("Must specify content topics");const i=ge(t),a=ge(s);let o;for(;;){const t={limit:n,direction:r,cursor:o},s=await this._query({contentTopics:[e],startTimeNs:i,endTimeNs:a,pagingInfo:t});if(!s.envelopes?.length)return;if(yield s.envelopes.map(it),!s.pagingInfo?.cursor)return;o=s.pagingInfo?.cursor}}async batchQuery(e){const t=[];for(let s=0;s<e.length;s+=50){const r=e.slice(s,s+50),n=[];for(const e of r)n.push({contentTopics:[e.contentTopic],startTimeNs:ge(e.startTime),endTimeNs:ge(e.endTime),pagingInfo:{limit:e.pageSize||10,direction:e.direction||Ze.SORT_DIRECTION_ASCENDING}});const i={requests:n};t.push(i)}const s=await Promise.all(t.map((async e=>this._batchQuery(e)))),r=[];for(const e of s){if(!e.responses)throw new Error("BatchQueryResponse missing responses");for(const t of e.responses)t.envelopes?r.push(t.envelopes.map(it)):r.push([])}return r}async publish(e){const t=[];for(const{contentTopic:s,message:r,timestamp:n}of e){if(!s.length)throw new Error("Content topic cannot be empty string");if(!r.length)throw new Error("0 length messages not allowed");const e=n||new Date;t.push({contentTopic:s,timestampNs:ge(e),message:Uint8Array.from(r)})}return this._publish({envelopes:t})}subscribe(e,t,s){if(!e.contentTopics.length)throw new Error("Must provide list of contentTopics to subscribe to");return this._subscribe(e,(e=>t(it(e))),s)}getToken(){if(!this.authCache)throw new Error("AuthCache is not set on API Client");return this.authCache.getToken()}setAuthenticator(e,t){this.authCache=new Ye(e,t)}headers(){const e=new Headers;return e.set("X-Client-Version",this.version),this.appVersion&&e.set("X-App-Version",this.appVersion),e}}class ot{constructor(e,t){this.disableOffset=!1,this.jobType=e,this.mutex=new S,this.keystore=t}get protoJobType(){return function(e){const t={v1:i.JobType.JOB_TYPE_REFRESH_V1,v2:i.JobType.JOB_TYPE_REFRESH_V2,"user-preferences":i.JobType.JOB_TYPE_REFRESH_PPPP}[e];if(!t)throw new Error(`unknown job type: ${e}`);return t}(this.jobType)}async run(e){return this.mutex.runExclusive((async()=>{const t=await this.getLastRunTime(),s=new Date,r=await e(t?this.disableOffset?t:new Date(t.getTime()-1e4):void 0);return await this.setLastRunTime(s),r}))}async resetLastRunTime(){await this.keystore.setRefreshJob({jobType:this.protoJobType,lastRunNs:fe(new Date(0))})}async getLastRunTime(){const{lastRunNs:e}=await this.keystore.getRefreshJob(i.GetRefreshJobRequest.fromPartial({jobType:this.protoJobType}));if(!e.equals(l.fromNumber(0)))return me(e)}async setLastRunTime(e){await this.keystore.setRefreshJob({jobType:this.protoJobType,lastRunNs:fe(e)})}}const ct=e=>Boolean(e.recipientAddress&&e.senderAddress);class dt{constructor(e){this.client=e,this.v1JobRunner=new ot("v1",e.keystore),this.v2JobRunner=new ot("v2",e.keystore)}async list(){const[e,t]=await Promise.all([this.listV1Conversations(),this.listV2Conversations()]),s=e.concat(t);return s.sort(((e,t)=>e.createdAt.getTime()-t.createdAt.getTime())),s}async listFromCache(){const[e,t]=await Promise.all([this.getV1ConversationsFromKeystore(),this.getV2ConversationsFromKeystore()]),s=e.concat(t);return s.sort(((e,t)=>e.createdAt.getTime()-t.createdAt.getTime())),s}async listV1Conversations(){return this.v1JobRunner.run((async e=>{const t=await this.getIntroductionPeers({startTime:e,direction:Ze.SORT_DIRECTION_ASCENDING});return await this.client.keystore.saveV1Conversations({conversations:Array.from(t).map((([e,t])=>({peerAddress:e,createdNs:fe(t),topic:Pe(e,this.client.address),context:void 0,consentProofPayload:void 0}))).filter((e=>Be(e.topic)))}),(await this.client.keystore.getV1Conversations()).conversations.map(this.conversationReferenceToV1.bind(this))}))}async listV2Conversations(){return this.v2JobRunner.run((async e=>{const t=await this.getV2ConversationsFromKeystore(),s=await this.updateV2Conversations(e),r=new Set(t.map((e=>e.topic)));for(const e of s)r.has(e.topic)||(t.push(e),r.add(e.topic));return t.sort(((e,t)=>e.createdAt.getTime()-t.createdAt.getTime())),t}))}async getV2ConversationsFromKeystore(){return(await this.client.keystore.getV2Conversations()).conversations.map(this.conversationReferenceToV2.bind(this))}async getV1ConversationsFromKeystore(){return(await this.client.keystore.getV1Conversations()).conversations.map(this.conversationReferenceToV1.bind(this))}async updateV2Conversations(e){const t=await this.client.listInvitations({startTime:e,direction:Ze.SORT_DIRECTION_ASCENDING});return this.decodeInvites(t)}async decodeInvites(e,t=!1){const{responses:s}=await this.client.keystore.saveInvites({requests:e.map((e=>({payload:e.message,timestampNs:l.fromString(e.timestampNs),contentTopic:e.contentTopic}))).filter((e=>Be(e.contentTopic)))}),r=[];for(const e of s)try{r.push(this.saveInviteResponseToConversation(e))}catch(e){if(console.warn("Error saving invite response to conversation: ",e),t)throw e}return r}saveInviteResponseToConversation({result:e,error:t}){if(t||!e||!e.conversation)throw new Error(`Error from keystore: ${t?.code} ${t?.message}}`);return this.conversationReferenceToV2(e.conversation)}conversationReferenceToV2(e){return new Ne(this.client,e.topic,e.peerAddress,me(e.createdNs),e.context,e.consentProofPayload)}conversationReferenceToV1(e){return new Re(this.client,e.peerAddress,me(e.createdNs))}async stream(e){const t=new Set,s=Te(this.client.address),r=Ce(this.client.address),n=[s,r];return he.create(this.client,n,(async e=>{if(e.contentTopic===s){if(!e.message)throw new Error("empty envelope");const s=await xe.fromBytes(e.message),r=this.getPeerAddress(s);if(!(e=>!t.has(e)&&(t.add(e),!0))(r))return;return await s.decrypt(this.client.keystore,this.client.publicKeyBundle),new Re(this.client,r,s.sent)}if(e.contentTopic===r){const t=await this.decodeInvites([e],!0);if(t.length)return t[0]}throw new Error("unrecognized invite topic")}).bind(this),void 0,e)}async streamAllMessages(e){const t=Te(this.client.address),s=Ce(this.client.address),r=new Set([t,s]),n=new Map;for(const e of await this.list())r.add(e.topic),n.set(e.topic,e);const i=(e,t)=>!r.has(e)&&(n.set(e,t),r.add(e),!0),a=await he.create(this.client,Array.from(r.values()),(async e=>{const r=e.contentTopic;if(!r||!e.message)return null;if(r===t){const t=await xe.fromBytes(e.message);if(!ct(t))return null;const s=this.getPeerAddress(t);return new Re(this.client,s,t.sent).decodeMessage(e)}if(r===s){return(await this.decodeInvites([e],!0))[0]}const i=n.get(r);if(i instanceof Re)return i.decodeMessage(e);if(i instanceof Ne)return i.decodeMessage(e);throw console.log("Unknown topic"),new Error("Unknown topic")}),(e=>{if(e instanceof Ve&&e.contentTopic===t){const t=new Re(this.client,e.recipientAddress?.toLowerCase()===this.client.address.toLowerCase()?e.senderAddress:e.recipientAddress,e.sent);return i(t.topic,t)?Array.from(r.values()):void 0}if(e instanceof Ne){return i(e.topic,e)?Array.from(r.values()):void 0}}),e),o=async function*(){for await(const e of a)if(e instanceof Ve&&(yield e),e instanceof Ne)for(const t of await e.messages())yield t}();return o.return=async()=>(await(a?.return()),{value:void 0,done:!0}),o}async getIntroductionPeers(e){const t=Te(this.client.address),s=await this.client.listEnvelopes(t,(e=>{if(!e.message)throw new Error("empty envelope");return xe.fromBytes(e.message)}),e),r=new Map;for(const e of s){if(!ct(e))continue;const t=this.getPeerAddress(e);if(t){const s=r.get(t);if(!s||s>e.sent)try{await e.decrypt(this.client.keystore,this.client.publicKeyBundle),r.set(t,e.sent)}catch(e){continue}}}return r}async newConversation(e,t,s){const r=s=>{return s.peerAddress.toLowerCase()===e.toLowerCase()&&(r=t,n=s.context??void 0,r?.conversationId===n?.conversationId);var r,n},n=(await this.getV2ConversationsFromKeystore()).find(r);if(n)return n;let i=await this.client.getUserContact(e);if(!i)throw new Error(`Recipient ${e} is not on the XMTP network`);if(e.toLowerCase()===this.client.address.toLowerCase())throw new Error("self messaging not supported");if(i instanceof ce&&!t?.conversationId)return new Re(this.client,e,new Date);if(!t?.conversationId){const t=(await this.listV1Conversations()).find((t=>t.peerAddress.toLowerCase()===e.toLowerCase()));if(t){if(!this.client.signedPublicKeyBundle.isFromLegacyBundle())throw new Error("cannot resume pre-existing V1 conversation; client keys not compatible");if(!(i instanceof ce||i.isFromLegacyBundle()))throw new Error("cannot resume pre-existing V1 conversation; peer keys not compatible");return t}}return i instanceof ce&&(i=oe.fromLegacyBundle(i)),this.v2JobRunner.run((async e=>{const n=(await this.updateV2Conversations(e)).find(r);return n||this.createV2Convo(i,t,s)}))}async createV2Convo(e,t,s){const r=new Date,{payload:n,conversation:i}=await this.client.keystore.createInvite({recipient:e,context:t,createdNs:fe(r),consentProof:s});if(!n||!i)throw new Error("Required field not returned from Keystore");const a=await e.walletSignatureAddress();return await this.client.publishEnvelopes([{contentTopic:Ce(a),message:n,timestamp:r},{contentTopic:Ce(this.client.address),message:n,timestamp:r}]),await this.client.contacts.allow([a]),this.conversationReferenceToV2(i)}getPeerAddress(e){return e.recipientAddress?.toLowerCase()===this.client.address.toLowerCase()?e.senderAddress:e.recipientAddress}}class ht{constructor(e){this.storage=e}static create(){if("undefined"==typeof localStorage)throw new Error("Missing LocalStorage. Use ephemeralPersistence instead");return new ht(localStorage)}async getItem(e){const t=this.storage.getItem(e);return null===t?null:Uint8Array.from(Buffer.from(t,"binary"))}async setItem(e,t){this.storage.setItem(e,Buffer.from(t).toString("binary"))}}class yt{constructor(){this.store=new Map}get length(){return this.store.size}clear(){this.store=new Map}getItem(e){return this.validateString(e),this.store.has(e)?String(this.store.get(e)):null}key(e){if(void 0===e)throw new TypeError("Failed to execute 'key' on 'Storage': 1 argument required, but only 0 present.");const t=[...this.store.keys()];return e>=t.length?null:t[e]}removeItem(e){this.validateString(e),this.store.delete(e)}setItem(e,t){this.validateString(e),this.validateString(t),this.store.set(String(e),String(t))}validateString(e){if("string"!=typeof e)throw new TypeError("Key must be a string")}}class ut extends ht{static create(){return new ht(new yt)}}class lt extends Error{}function pt(e,t,s,r){if("a"===s&&!r)throw new TypeError("Private accessor was defined without a getter");if("function"==typeof t?e!==t||!r:!t.has(e))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===s?r:"a"===s?r.call(e):r?r.value:t.get(e)}function wt(e,t,s,r,n){if("m"===r)throw new TypeError("Private method is not writable");if("a"===r&&!n)throw new TypeError("Private accessor was defined without a setter");if("function"==typeof t?e!==t||!n:!t.has(e))throw new TypeError("Cannot write private member to an object whose class did not declare it");return"a"===r?n.call(e,s):n?n.value=s:t.set(e,s),s}"function"==typeof SuppressedError&&SuppressedError;class ft{constructor(e){if(!e.publicKey.signature)throw new Error("Provided public key is not signed");this.identityKey=e}async createToken(e){const t=Fe.create(this.identityKey.publicKey.walletSignatureAddress(),e||new Date).toBytes(),n=f(t),i=await this.identityKey.sign(v(n));return new $e(c.Token.fromPartial({identityKey:r.PublicKey.fromPartial(this.identityKey.publicKey),authDataBytes:t,authDataSignature:s.Signature.fromPartial(i)}))}}const mt=new(0,A.ec)("secp256k1"),gt=N.subtle,vt=Buffer.from("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141","hex"),bt=Buffer.alloc(32,0);function Et(e,t){if(!e)throw new Error(t||"Assertion failed")}function Kt(e){return t=e,!(!Buffer.isBuffer(t)||32!==t.length)&&(e.compare(bt)>0&&e.compare(vt)<0);var t}function kt(e){const t=new Uint8Array(e);return N.getRandomValues(t),Buffer.from(t)}async function Pt(e){const t=await gt.digest("SHA-512",e);return Buffer.from(t)}function St(e){return function(t,s,r){return new Promise((function(n){return gt.importKey("raw",s,{name:"AES-CBC"},!1,[e]).then((function(s){const n={name:"AES-CBC",iv:t};return gt[e](n,s,r)})).then((function(e){n(Buffer.from(new Uint8Array(e)))}))}))}}const At=St("encrypt"),Tt=St("decrypt");async function Ct(e,t){const s=await gt.importKey("raw",e,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]);return Buffer.from(await gt.sign({name:"HMAC",hash:"SHA-256"},s,t))}function It(e){return Et(32===e.length,"Bad private key"),Et(Kt(e),"Bad private key"),Buffer.from(mt.keyFromPrivate(e).getPublic("array"))}function Bt(e,t){return new Promise((function(s){Et(Buffer.isBuffer(e),"Bad private key"),Et(Buffer.isBuffer(t),"Bad public key"),Et(32===e.length,"Bad private key"),Et(Kt(e),"Bad private key"),Et(65===t.length||33===t.length,"Bad public key"),65===t.length&&Et(4===t[0],"Bad public key"),33===t.length&&Et(2===t[0]||3===t[0],"Bad public key");const r=mt.keyFromPrivate(e),n=mt.keyFromPublic(t),i=r.derive(n.getPublic());s(Buffer.from(i.toArray()))}))}async function Rt(e,t){const s=await Bt(e,t.ephemeralPublicKey),r=await Pt(s),n=r.slice(0,32),i=r.slice(32),a=Buffer.concat([t.iv,t.ephemeralPublicKey,t.ciphertext]);return Et(await async function(e,t,s){return function(e,t){if(e.length!==t.length)return!1;let s=0;for(let r=0;r<e.length;r++)s|=e[r]^t[r];return 0===s}(await Ct(e,t),s)}(i,a,t.mac),"Bad mac"),Tt(t.iv,n,t.ciphertext)}async function Nt(e,t){const s=e.publicKey.secp256k1Uncompressed.bytes,r=e.secp256k1.bytes;return T(s,r,t)}async function Dt(e,t){const s=e.publicKey.secp256k1Uncompressed.bytes,r=e.secp256k1.bytes;return C(s,r,t)}class Mt{constructor({topic:e,context:t,aes256GcmHkdfSha256:s,consentProof:r}){if(!e||!e.length)throw new Error("Missing topic");if(!s||!s.keyMaterial||!s.keyMaterial.length)throw new Error("Missing key material");this.topic=e,this.context=t,this.aes256GcmHkdfSha256=s,this.consentProof=r}static createRandom(e,t){const s=Se(Buffer.from(N.getRandomValues(new Uint8Array(32))).toString("base64").replace(/=*$/g,"").replace(/\//g,"-")),r=N.getRandomValues(new Uint8Array(32));return new Mt({topic:s,aes256GcmHkdfSha256:{keyMaterial:r},context:e,consentProof:t})}toBytes(){return h.InvitationV1.encode(this).finish()}static fromBytes(e){return new Mt(h.InvitationV1.decode(e))}}class xt{constructor({sender:e,recipient:t,createdNs:s}){if(!e)throw new Error("Missing sender");if(!t)throw new Error("Missing recipient");this.sender=new oe(e),this.recipient=new oe(t),this.createdNs=s}toBytes(){return h.SealedInvitationHeaderV1.encode(this).finish()}static fromBytes(e){return new xt(h.SealedInvitationHeaderV1.decode(e))}}class _t{constructor({headerBytes:e,ciphertext:t}){if(!e||!e.length)throw new Error("Missing header bytes");if(!t)throw new Error("Missing ciphertext");this.headerBytes=e,this.ciphertext=new R(t)}get header(){return this._header||(this._header=xt.fromBytes(this.headerBytes)),this._header}async getInvitation(e){if(this._invitation)return this._invitation;const t=this.header;let s;s=e.identityKey.matches(this.header.sender.identityKey)?await e.sharedSecret(t.recipient,t.sender.preKey,!1):await e.sharedSecret(t.sender,t.recipient.preKey,!0);const r=await V(this.ciphertext,s,this.headerBytes);return this._invitation=Mt.fromBytes(r),this._invitation}toBytes(){return h.SealedInvitationV1.encode(this).finish()}static fromBytes(e){return new _t(h.SealedInvitationV1.decode(e))}}class Vt{constructor({v1:e}){if(!e)throw new Error("Missing v1 or v2 invitation");this.v1=new _t(e)}toBytes(){return h.SealedInvitation.encode(this).finish()}static fromBytes(e){return new Vt(h.SealedInvitation.decode(e))}static async fromEnvelope(e){if(!e.message||!e.timestampNs)throw new Error("invalid invitation envelope");const t=Vt.fromBytes(e.message),s=l.fromString(e.timestampNs),r=t.v1?.header.createdNs;if(!r||!r.equals(s))throw new Error("envelope and header timestamp mistmatch");return t}static async createV1({sender:e,recipient:t,created:s,invitation:r}){const n=new xt({sender:e.getPublicKeyBundle(),recipient:t,createdNs:fe(s)}).toBytes(),i=await e.sharedSecret(t,e.getCurrentPreKey().publicKey,!1),a=r.toBytes(),o=await _(a,i,n);return new Vt({v1:{headerBytes:n,ciphertext:o}})}}var Ut,Ot,qt,Lt,Gt,Ht;class Ft{constructor(e,t,s=new Map){Ut.add(this),Ot.set(this,void 0),qt.set(this,void 0),Lt.set(this,void 0),Gt.set(this,void 0),wt(this,qt,t,"f"),wt(this,Ot,e,"f"),wt(this,Gt,0,"f"),wt(this,Lt,new S,"f"),this.actionsMap=s}get revisionKey(){return pt(this,qt,"f")+"/revision"}static async create(e){const t=new Ft(e,"private-preferences/actions");return await t.refresh(),t}async refresh(){const e=await this.getRevision();e>pt(this,Gt,"f")&&(this.actionsMap=await this.loadFromPersistence()),wt(this,Gt,e,"f")}async getRevision(){const e=await pt(this,Ot,"f").getItem(this.revisionKey);return e?we(e):0}async setRevision(e){await pt(this,Ot,"f").setItem(this.revisionKey,pe(e))}async loadFromPersistence(){const e=await pt(this,Ot,"f").getItem(pt(this,qt,"f"));if(!e)return new Map;const t=i.PrivatePreferencesActionMap.decode(e),s=new Map,r=Object.entries(t.actions);for(let e=0;e<r.length;e++)s.set(r[e][0],r[e][1]);return s}async store(){var e;await pt(this,Ot,"f").setItem(pt(this,qt,"f"),pt(this,Ut,"m",Ht).call(this)),wt(this,Gt,(e=pt(this,Gt,"f"),++e),"f"),await this.setRevision(pt(this,Gt,"f"))}async add(e){await pt(this,Lt,"f").runExclusive((async()=>{await this.refresh();let t=!1;const s=Array.from(e.keys());for(let r=0;r<s.length;r++)this.actionsMap.has(s[r])||(this.actionsMap.set(s[r],e.get(s[r])),t=!0);t&&await this.store()}))}get actions(){return new Map([...this.actionsMap.entries()].sort(((e,t)=>ve(e[0]).getTime()-ve(t[0]).getTime())))}lookup(e){return this.actionsMap.get(e)}}Ot=new WeakMap,qt=new WeakMap,Lt=new WeakMap,Gt=new WeakMap,Ut=new WeakSet,Ht=function(){return i.PrivatePreferencesActionMap.encode({actions:Object.fromEntries(this.actionsMap)}).finish()};const $t=(e,t)=>e instanceof be?e:new be(t,e.message),jt=(e,t,s)=>Promise.all(e.map((async e=>{try{return{result:await t(e)}}catch(e){return{error:$t(e,s)}}}))),Xt=e=>e instanceof ce?e:new ce(e),Jt=(e,t,s)=>{for(const s of t)if(!e[s])throw new be(i.ErrorCode.ERROR_CODE_INVALID_INPUT,`Missing field ${String(s)}`);for(const t of s){const s=e[t];if(!s||!s?.length)throw new be(i.ErrorCode.ERROR_CODE_INVALID_INPUT,`Missing field ${String(t)}`)}return!0},zt=e=>{if(!e?.aes256GcmHkdfSha256?.keyMaterial)throw new be(i.ErrorCode.ERROR_CODE_INVALID_INPUT,"Missing key material");return e.aes256GcmHkdfSha256.keyMaterial},Wt=({invitation:e,createdNs:t,peerAddress:s})=>({context:e.context,topic:e.topic,peerAddress:s,createdNs:t,consentProofPayload:e.consentProof});class Yt{constructor(e,t,s=new Map){this.persistenceKey=t,this.persistence=e,this.revision=0,this.mutex=new S,this.topicMap=s}get revisionKey(){return this.persistenceKey+"/revision"}static async create(e){const t=new Yt(e,"invitations/v1");return await t.refresh(),t}validate(e){return!!e.topic&&e.topic.length>0&&!!e.invitation}async refresh(){const e=await this.getRevision();if(e>this.revision)for(const[e,t]of await this.loadFromPersistence())this.topicMap.set(e,t);this.revision=e}async getRevision(){const e=await this.persistence.getItem(this.revisionKey);return e?we(e):0}async setRevision(e){await this.persistence.setItem(this.revisionKey,pe(e))}async loadFromPersistence(){const e=await this.persistence.getItem(this.persistenceKey);return e?(e=>{const t=new Map;for(const[s,r]of Object.entries(e.topics))t.set(s,r);return t})(i.TopicMap.decode(e)):new Map}async store(){await this.persistence.setItem(this.persistenceKey,this.toBytes()),this.revision++,await this.setRevision(this.revision)}async add(e){await this.mutex.runExclusive((async()=>{await this.refresh();let t=!1;for(const s of e){if(!this.validate(s)){console.warn("Invalid topic data",s.topic);continue}const{topic:e,...r}=s;this.topicMap.has(e)||(this.topicMap.set(e,r),t=!0)}t&&await this.store()}))}get topics(){return[...this.topicMap.values()]}lookup(e){return this.topicMap.get(e)}toBytes(){return i.TopicMap.encode({topics:Object.fromEntries(this.topicMap)}).finish()}}class Qt extends Yt{static async create(e){const t=new Qt(e,"conversation-v1/v1");return await t.refresh(),t}validate(e){return!!(e.topic&&e.topic.length&&e.peerAddress?.length>0)}}const Zt=async(e,t,s,r)=>_(s,await e.sharedSecret(t,e.getCurrentPreKey().publicKey,!1),r);var es;const{ErrorCode:ts}=i,ss=(new TextEncoder).encode("__XMTP__INVITATION__SALT__XMTP__");class rs{constructor(e,t,s,r,n){es.set(this,void 0),this.v1Keys=e,this.v2Keys=Le.fromLegacyBundle(e),this.v1Store=t,this.v2Store=s,this.privatePreferencesStore=r,this.authenticator=new ft(e.identityKey),this.jobStatePersistence=n}static async create(e,t){return new rs(e,await Qt.create(t),await Yt.create(t),await Ft.create(t),t)}get walletAddress(){return this.v1Keys.identityKey.publicKey.walletSignatureAddress()}async decryptV1(e){const t=await jt(e.requests,(async e=>{Jt(e,["payload","peerKeys"],["headerBytes"]);const{payload:t,peerKeys:s,headerBytes:r,isSender:n}=e,i=await(async(e,t,s,r,n)=>V(s,await e.sharedSecret(t,e.getCurrentPreKey().publicKey,!n),r))(this.v1Keys,Xt(s),t,r,n);return{decrypted:i}}),i.ErrorCode.ERROR_CODE_UNSPECIFIED);return i.DecryptResponse.fromPartial({responses:t})}async decryptV2(e){const t=await jt(e.requests,(async e=>{Jt(e,["payload"],["headerBytes"]);const{payload:t,headerBytes:s,contentTopic:r}=e,n=this.v2Store.lookup(r);if(!n)throw new be(i.ErrorCode.ERROR_CODE_NO_MATCHING_PREKEY,"no topic key");const a=await((e,t,s)=>V(e,t,s))(t,zt(n.invitation),s);return{decrypted:a}}),ts.ERROR_CODE_UNSPECIFIED);return i.DecryptResponse.fromPartial({responses:t})}async encryptV1(e){const t=await jt(e.requests,(async e=>{Jt(e,["payload","recipient"],["headerBytes"]);const{recipient:t,payload:s,headerBytes:r}=e;return{encrypted:await Zt(this.v1Keys,Xt(t),s,r)}}),ts.ERROR_CODE_UNSPECIFIED);return i.EncryptResponse.fromPartial({responses:t})}async createAuthToken({timestampNs:e}){return this.authenticator.createToken(e?me(e):void 0)}async selfEncrypt(e){const t=await jt(e.requests,(async e=>{const{payload:t}=e;if(!t)throw new be(ts.ERROR_CODE_INVALID_INPUT,"Missing field payload");return{encrypted:await Nt(this.v1Keys.identityKey,t)}}),ts.ERROR_CODE_INVALID_INPUT);return i.SelfEncryptResponse.fromPartial({responses:t})}async selfDecrypt(e){const t=await jt(e.requests,(async e=>{const{payload:t}=e;if(!t)throw new be(ts.ERROR_CODE_INVALID_INPUT,"Missing field payload");return{decrypted:await Dt(this.v1Keys.identityKey,t)}}),ts.ERROR_CODE_INVALID_INPUT);return i.DecryptResponse.fromPartial({responses:t})}async getPrivatePreferencesTopicIdentifier(){const e=await async function(e){const t=e.secp256k1.bytes;return I(t)}(this.v1Keys.identityKey);return i.GetPrivatePreferencesTopicIdentifierResponse.fromPartial({identifier:e})}async encryptV2(e){const t=await jt(e.requests,(async e=>{Jt(e,["payload"],["headerBytes"]);const{payload:t,headerBytes:s,contentTopic:r}=e,n=this.v2Store.lookup(r);if(!n)throw new be(ts.ERROR_CODE_NO_MATCHING_PREKEY,"no topic key");const i=zt(n.invitation),a=await((e,t,s)=>_(e,t,s))(t,i,s),o=`${Math.floor(Date.now()/1e3/60/60/24/30)}-${await this.getAccountAddress()}`;return{encrypted:a,senderHmac:await L(i,(new TextEncoder).encode(o),s)}}),ts.ERROR_CODE_INVALID_INPUT);return i.EncryptResponse.fromPartial({responses:t})}async saveInvites(e){const t=[],s=await jt(e.requests,(async({payload:e,timestampNs:s})=>{const r=Vt.fromBytes(e);if(r.v1){if(!r.v1.header.createdNs.equals(s))throw new Error("envelope and header timestamp mismatch");const e=r.v1.header.sender.equals(this.v2Keys.getPublicKeyBundle()),n=await r.v1.getInvitation(this.v2Keys),i={invitation:n,createdNs:r.v1.header.createdNs,peerAddress:e?await r.v1.header.recipient.walletSignatureAddress():await r.v1.header.sender.walletSignatureAddress()};return t.push({...i,topic:n.topic}),{conversation:Wt(i)}}}),ts.ERROR_CODE_INVALID_INPUT);return await this.v2Store.add(t),i.SaveInvitesResponse.fromPartial({responses:s})}async createInvite(e){try{Jt(e,["recipient"],[]);const s=me(e.createdNs),r=(t=e.recipient)instanceof oe?t:new oe(t),n=await this.getAccountAddress(),a=await r.walletSignatureAddress(),o=await this.v2Keys.sharedSecret(r,this.v2Keys.getCurrentPreKey().publicKey,n<a),c=[n,a].sort(),d=(e.context?.conversationId||"")+c.join(),h=(new TextEncoder).encode(d),y=$(await Ct(Buffer.from(o),Buffer.from(h))),u=["0",...c].join("|"),l=(new TextEncoder).encode(u),p=await async function(e,t){const s=await N.subtle.importKey("raw",e,"HKDF",!1,["deriveKey"]);return N.subtle.deriveKey({name:"HKDF",hash:"SHA-256",salt:ss,info:t},s,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"])}(o,l),w=new Uint8Array(await N.subtle.exportKey("raw",p)),f=new Mt({topic:Se(y),aes256GcmHkdfSha256:{keyMaterial:w},context:e.context,consentProof:e.consentProof}),m=await Vt.createV1({sender:this.v2Keys,recipient:r,created:s,invitation:f}),g={invitation:f,topic:f.topic,createdNs:e.createdNs,peerAddress:await r.walletSignatureAddress()};return await this.v2Store.add([g]),i.CreateInviteResponse.fromPartial({conversation:Wt(g),payload:m.toBytes()})}catch(e){throw $t(e,ts.ERROR_CODE_INVALID_INPUT)}var t}async signDigest(e){Jt(e,["digest"],[]);const{digest:t,identityKey:s,prekeyIndex:r}=e;let n;if(s)n=this.v1Keys.identityKey;else{if(void 0===r||!Number.isInteger(r))throw new be(ts.ERROR_CODE_INVALID_INPUT,"must specifify identityKey or prekeyIndex");if(n=this.v1Keys.preKeys[r],!n)throw new be(ts.ERROR_CODE_NO_MATCHING_PREKEY,"no prekey found")}return n.sign(t)}async saveV1Conversations({conversations:e}){return await this.v1Store.add(e.map((e=>({topic:Pe(e.peerAddress,this.walletAddress),peerAddress:e.peerAddress,createdNs:e.createdNs,invitation:void 0})))),{}}async getV1Conversations(){return{conversations:this.v1Store.topics.map(this.topicDataToV1ConversationReference.bind(this))}}async getV2Conversations(){const e=this.v2Store.topics.map((e=>Wt(e)));return e.sort(((e,t)=>e.createdNs.div(1e6).sub(t.createdNs.div(1e6)).toNumber())),i.GetConversationsResponse.fromPartial({conversations:e})}async getPublicKeyBundle(){return this.v1Keys.getPublicKeyBundle()}async getPrivateKeyBundle(){return this.v1Keys}async getAccountAddress(){return this.accountAddress||(this.accountAddress=await this.v2Keys.getPublicKeyBundle().walletSignatureAddress()),this.accountAddress}async getRefreshJob({jobType:e}){if(e===i.JobType.JOB_TYPE_UNSPECIFIED)throw new be(ts.ERROR_CODE_INVALID_INPUT,"invalid job type");const t=await this.getLastRunTime(e);return i.GetRefreshJobResponse.fromPartial({lastRunNs:t||l.fromNumber(0)})}async setRefreshJob({jobType:e,lastRunNs:t}){const s=await this.buildJobStorageKey(e);return await this.jobStatePersistence.setItem(s,Uint8Array.from(t.toBytes())),{}}topicDataToV1ConversationReference(e){return{peerAddress:e.peerAddress,createdNs:e.createdNs,topic:Pe(e.peerAddress,this.walletAddress),context:void 0,consentProofPayload:void 0}}buildJobStorageKey(e){return`refreshJob/${e.toString()}`}async getLastRunTime(e){const t=await this.jobStatePersistence.getItem(this.buildJobStorageKey(e));if(t&&t.length)return l.fromBytes([...t])}lookupTopic(e){return this.v2Store.lookup(e)}async getV2ConversationHmacKeys(e){const t=Math.floor(Date.now()/1e3/60/60/24/30),s={};let r=this.v2Store.topics;return e?.topics&&(r=r.filter((t=>void 0!==t.invitation&&e.topics.includes(t.invitation.topic)))),await Promise.all(r.map((async e=>{if(e.invitation?.topic){const r=zt(e.invitation),n=await Promise.all([t-1,t,t+1].map((async e=>{const t=`${e}-${await this.getAccountAddress()}`,s=await q(r,(new TextEncoder).encode(t));return{thirtyDayPeriodsSinceEpoch:e,hmacKey:await H(s)}})));s[e.invitation.topic]={values:n}}}))),{hmacKeys:s}}async getPrivatePreferencesTopic(){if(!pt(this,es,"f")){const{identifier:e}=await this.getPrivatePreferencesTopicIdentifier();wt(this,es,(e=>ke(`userpreferences-${e}`))(e),"f")}return pt(this,es,"f")}async createPrivatePreference(e){const{responses:t}=await this.selfEncrypt({requests:[{payload:y.PrivatePreferencesAction.encode(e).finish()}]}),s=t.reduce(((e,t)=>t.result?.encrypted?e.concat(t.result?.encrypted):e),[]),r=await this.getPrivatePreferencesTopic(),n=new Date;return s.map((e=>({contentTopic:r,message:e,timestamp:n})))}getPrivatePreferences(){return this.privatePreferencesStore.actions}savePrivatePreferences(e){return this.privatePreferencesStore.add(e)}}es=new WeakMap;class ns{constructor(e){this.apiClient=e}async getItem(e){for await(const t of this.apiClient.queryIterator({contentTopic:this.buildTopic(e)},{pageSize:1,direction:d.SortDirection.SORT_DIRECTION_DESCENDING}))if(t.message)try{return Uint8Array.from(t.message)}catch(e){console.log(e)}return null}async setItem(e,t){const s=Uint8Array.from(t);await this.apiClient.publish([{contentTopic:this.buildTopic(e),message:s}])}setAuthenticator(e){this.apiClient.setAuthenticator(e)}buildTopic(e){return Ie(e)}}class is{constructor({eciesBytes:t,signature:s}){if(!t||!t.length)throw new Error("eciesBytes is empty");if(!s)throw new Error("signature is undefined");this.eciesBytes=t,this.signature=new ee(s),this.ciphertext=e.SignedEciesCiphertext_Ecies.decode(t)}toBytes(){return e.SignedEciesCiphertext.encode(this).finish()}async verify(e){return e.verify(this.signature,await x(this.eciesBytes))}static fromBytes(t){const s=e.SignedEciesCiphertext.decode(t);return new is(s)}static async create(t,s){(e=>{if(16!==e.iv.length)throw new Error("Invalid iv length");if(65!==e.ephemeralPublicKey.length)throw new Error("Invalid ephemPublicKey length");if(e.ciphertext.length<1||e.ciphertext.length%16!=0)throw new Error("Invalid ciphertext length");if(32!==e.mac.length)throw new Error("Invalid mac length")})(t);const r=e.SignedEciesCiphertext_Ecies.encode(t).finish(),n=await s.sign(await x(r));return new is({eciesBytes:r,signature:n})}}class as{constructor(e,t){this.persistence=e,this.privateKey=t,this.privateKeyBytes=Buffer.from(t.secp256k1.bytes),this.publicKey=It(this.privateKeyBytes)}async getItem(e){const t=await this.persistence.getItem(e);return t?this.decrypt(t):null}async setItem(e,t){const s=await this.encrypt(t);await this.persistence.setItem(e,s)}async encrypt(e){const t=await async function(e,t,s){s=s||{};const r=s?.iv||kt(16);let n=s?.ephemPrivateKey||kt(32);for(;!Kt(n);){if(s?.ephemPrivateKey)throw new Error("ephemPrivateKey is not valid");n=kt(32)}const i=It(n),a=await Pt(await Bt(n,e)),o=a.slice(0,32),c=a.slice(32),d=await At(r,o,t),h=Buffer.concat([r,i,d]);return{iv:r,ephemeralPublicKey:i,ciphertext:d,mac:await Ct(c,h)}}(this.publicKey,Buffer.from(e));return this.serializeEcies(t)}async decrypt(e){const t=await this.deserializeEcies(e),s=await Rt(this.privateKeyBytes,t);return Uint8Array.from(s)}async serializeEcies(e){return(await is.create(e,this.privateKey)).toBytes()}async deserializeEcies(e){const t=is.fromBytes(e);if(!await t.verify(this.privateKey.publicKey))throw new Error("signature validation failed");const s=t.ciphertext;return{ciphertext:Buffer.from(s.ciphertext),mac:Buffer.from(s.mac),iv:Buffer.from(s.iv),ephemeralPublicKey:Buffer.from(s.ephemeralPublicKey)}}}class os{constructor(e,t){this.prefix=e,this.persistence=t}getItem(e){return this.persistence.getItem(this.buildKey(e))}setItem(e,t){return this.persistence.setItem(this.buildKey(e),t)}buildKey(e){return this.prefix+e}}const cs=async(e,t)=>{if(!e.persistConversations)return ut.create();const s=await t.identityKey.publicKey.walletSignatureAddress(),r=`xmtp/${e.env}/${s}/`;const n=e.basePersistence,i=!e.disablePersistenceEncryption;return new os(r,i?new as(n,t.identityKey):n)},ds="key_bundle";class hs{constructor(e,t,s){this.signer=e,this.persistence=t,this.preEnableIdentityCallback=s}async getStorageAddress(e){let t=await this.signer.getAddress();return t=m(t),`${t}/${e}`}async loadPrivateKeyBundle(){const e=await this.persistence.getItem(await this.getStorageAddress(ds));if(!e)return null;const[t,s]=await this.fromEncryptedBytes(this.signer,Uint8Array.from(e));return s&&await this.storePrivateKeyBundle(t),t}async storePrivateKeyBundle(e){const t=await this.getStorageAddress(ds),s=await this.toEncryptedBytes(e,this.signer);"function"==typeof this.persistence.setAuthenticator&&this.persistence.setAuthenticator(new ft(e.identityKey)),await this.persistence.setItem(t,s)}async toEncryptedBytes(e,s){const r=e.encode(),n=N.getRandomValues(new Uint8Array(32)),i=us(n),a=await s.getAddress();this.preEnableIdentityCallback&&await this.preEnableIdentityCallback();const o=await s.signMessage(i);if(!E({address:a,message:i,signature:o}))throw new Error("invalid signature");const c=v(o),d=await _(r,c);return t.EncryptedPrivateKeyBundle.encode({v1:{walletPreKey:n,ciphertext:d}}).finish()}async fromEncryptedBytes(e,s){const[r,n]=function(e){try{const s=t.EncryptedPrivateKeyBundle.decode(e);if(s.v1)return[s.v1,!1]}catch(s){return[t.EncryptedPrivateKeyBundleV1.decode(e),!0]}throw new Error("unrecognized encrypted private key bundle version")}(s);if(!r.walletPreKey)throw new Error("missing wallet pre-key");if(!r.ciphertext?.aes256GcmHkdfSha256)throw new Error("missing bundle ciphertext");this.preEnableIdentityCallback&&await this.preEnableIdentityCallback();const i=v(await e.signMessage(us(r.walletPreKey)));try{const e=new R(r.ciphertext),t=await V(e,i),[s,a]=ys(t);return[s,n||a]}catch(e){if(65!==i.length)throw new Error("Expected 65 bytes before trying a different recovery byte");const t=i[i.length-1];let s=i.slice(0,i.length-1);s=t<27?new Uint8Array([...s,t+27]):new Uint8Array([...s,t-27]);const a=new R(r.ciphertext),o=await V(a,s),[c,d]=ys(o);return[c,n||d]}}}function ys(e){try{const t=He(e);if(t instanceof Le)throw new Error("V2 bundles not supported yet");return[t,!1]}catch(s){const r=t.PrivateKeyBundleV1.decode(e);return[new Ge(r),!0]}}function us(e){return`XMTP : Enable Identity\n${$(e)}\n\nFor more info: https://xmtp.org/signatures/`}class ls{async newKeystore(e,t,s){if(!s)throw new lt("Wallet required to generate new keys");e.preCreateIdentityCallback&&await e.preCreateIdentityCallback();const r=await Ge.generate(s),n=new hs(s,new ns(t),e.preEnableIdentityCallback);return await n.storePrivateKeyBundle(r),rs.create(r,await cs(e,r))}}class ps{async newKeystore(e,t,s){if(!s)throw new lt("No wallet provided");const r=new hs(s,new ns(t),e.preEnableIdentityCallback),n=await r.loadPrivateKeyBundle();if(!n)throw new lt("No keys found");return rs.create(n,await cs(e,n))}}function ws(){return window.ethereum}function fs(e){const[t,s,...r]=e.split(".");return{major:Number(t),minor:Number(s),patch:r.join(".")}}function ms(e,t){if(!e||!t)return!1;const s=fs(e),r=fs(t);return s.major!==r.major?s.major>r.major:s.minor!==r.minor?s.minor>r.minor:!(!s.patch||!r.patch)&&function(e,t){const[s,r]=e.split("-"),[n,i]=t.split("-");if(Number(s)!==Number(n))return Number(s)>Number(n);if(!r||!i)return!1;const[a,o]=r.split("."),[c,d]=i.split(".");if(a!==c)return!0;return Number(o)>Number(d)}(s.patch,r.patch)}const{GetKeystoreStatusResponse_KeystoreStatus:gs,InitKeystoreRequest:vs,InitKeystoreResponse:bs,GetKeystoreStatusRequest:Es,GetKeystoreStatusResponse:Ks}=i;async function ks(e,t,s,r,n){let i=null;if(t.req){const e=(0,t.req.encode)(s).finish();i=ue(e,0,e.length)}const a=await async function(e,t,s,r){const n={meta:s};"string"==typeof t&&(n.req=t);const i=await(ws()?.request({method:"wallet_invokeSnap",params:{snapId:r,request:{method:e,params:n}}}));if(!i||"object"!=typeof i)throw new Error("No response value");return i.res}(e,i,r,n);if(Array.isArray(a))throw new Error("Unexpected array response");return t.res.decode(ye(a))}async function Ps(){const e=ws();if(e?.isMetaMask)try{return await e.request({method:"wallet_getSnaps"}),!0}catch{}if(void 0!==e?.detected&&Array.isArray(e.detected))for(const t of e.detected)try{return await t.request({method:"wallet_getSnaps"}),e?.setProvider?.(t),!0}catch{}if(void 0!==e?.providers&&Array.isArray(e.providers))for(const t of e.providers)try{return await t.request({method:"wallet_getSnaps"}),window.ethereum=t,!0}catch{}return!1}async function Ss(e,t){try{const s=await async function(){return await(ws()?.request({method:"wallet_getSnaps"}))}();return s?Object.values(s).find((s=>{return s&&s.id===e&&(!t||(r=s.version,n=t,!r||!n||fs(r).major===fs(n).major));var r,n})):void 0}catch(e){return void console.warn("Failed to obtain installed snap",e)}}const As={req:Es,res:Ks};const Ts={req:vs,res:bs};const Cs={decryptV1:{req:i.DecryptV1Request,res:i.DecryptResponse},decryptV2:{req:i.DecryptV2Request,res:i.DecryptResponse},encryptV1:{req:i.EncryptV1Request,res:i.EncryptResponse},encryptV2:{req:i.EncryptV2Request,res:i.EncryptResponse},saveInvites:{req:i.SaveInvitesRequest,res:i.SaveInvitesResponse},createInvite:{req:i.CreateInviteRequest,res:i.CreateInviteResponse},createAuthToken:{req:i.CreateAuthTokenRequest,res:c.Token},signDigest:{req:i.SignDigestRequest,res:s.Signature},getPublicKeyBundle:{req:null,res:r.PublicKeyBundle},getPrivateKeyBundle:{req:null,res:t.PrivateKeyBundleV1},saveV1Conversations:{req:i.SaveV1ConversationsRequest,res:i.SaveV1ConversationsResponse},getV1Conversations:{req:null,res:i.GetConversationsResponse},getV2Conversations:{req:null,res:i.GetConversationsResponse},getRefreshJob:{req:i.GetRefreshJobRequest,res:i.GetRefreshJobResponse},setRefreshJob:{req:i.SetRefeshJobRequest,res:i.SetRefreshJobResponse},selfEncrypt:{req:i.SelfEncryptRequest,res:i.SelfEncryptResponse},selfDecrypt:{req:i.SelfDecryptRequest,res:i.DecryptResponse},getPrivatePreferencesTopicIdentifier:{req:null,res:i.GetPrivatePreferencesTopicIdentifierResponse},getV2ConversationHmacKeys:{req:i.GetConversationHmacKeysRequest,res:i.GetConversationHmacKeysResponse}},Is={getKeystoreStatus:{req:i.GetKeystoreStatusRequest,res:i.GetKeystoreStatusResponse},initKeystore:{req:i.InitKeystoreRequest,res:i.InitKeystoreResponse}};const{GetKeystoreStatusResponse_KeystoreStatus:Bs}=i;class Rs{constructor(e="local:http://localhost:8080",t){this.snapId=e,this.snapVersion=t}async newKeystore(e,t,s){if(!s)throw new lt("No wallet provided");if(!await Ps())throw new lt("MetaMask with Snaps not detected");const r=await s.getAddress(),n=e.env,i=await Ss(this.snapId,this.snapVersion);if(i&&!ms(this.snapVersion,i.version)||await async function(e,t={}){await(ws()?.request({method:"wallet_requestSnaps",params:{[e]:t}}))}(this.snapId,this.snapVersion?{version:this.snapVersion}:{}),!await async function(e,t,s){const r=await async function(e,t){const s=await ks("getKeystoreStatus",As,{walletAddress:e.walletAddress},e,t);if([gs.KEYSTORE_STATUS_UNSPECIFIED,gs.UNRECOGNIZED].includes(s.status))throw new Error("No status specified in response");return s.status}({walletAddress:e,env:t},s);if(r===Bs.KEYSTORE_STATUS_INITIALIZED)return!0;return!1}(r,n,this.snapId)){const r=await async function(e,t,s){if(e.privateKeyOverride){const t=He(e.privateKeyOverride);if(!(t instanceof Ge))throw new Error("Unsupported private key bundle version");return t}if(!s)throw new Error("No privateKeyOverride or wallet");return async function(e,t,s){const r=new ps;try{const n=await r.newKeystore(e,t,s);return new Ge(await n.getPrivateKeyBundle())}catch(r){if(r instanceof lt)return async function(e,t,s){const r=new ls,n=await r.newKeystore(e,t,s);return new Ge(await n.getPrivateKeyBundle())}(e,t,s);throw r}}(e,t,s)}(e,t,s);await async function(e,t,s){const r=e.identityKey.publicKey.walletSignatureAddress(),n=await ks("initKeystore",Ts,{v1:e},{walletAddress:r,env:t},s);if(n.error)throw new be(n.error.code,n.error.message)}(r,n,this.snapId)}return function(e,t,s){const r={},n={walletAddress:e,env:t};for(const[e,t]of Object.entries(Is))r[e]=async r=>t.req?ks(e,t,r,n,s):ks(e,t,void 0,n,s);return{...r,getAccountAddress:async()=>e}}(r,n,this.snapId)}}class Ns{async newKeystore(e){const{privateKeyOverride:t}=e;if(!t)throw new lt("No private key override provided");const s=He(t);if(s instanceof Le)throw new Error("V2 private key bundle found. Only V1 supported");return rs.create(s,await cs(e,s))}}function Ds(e){if(!e)return null;if(function(e){return"type"in e&&("walletClient"===e.type||"base"===e.type)}(e))return function(e){const{account:t}=e;if(!t||!t.address)throw new Error("WalletClient is not configured");return{getAddress:async()=>t.address,signMessage:async s=>e.signMessage({message:"string"==typeof s?s:{raw:s},account:t})}}(e);if("function"!=typeof e.getAddress)throw new Error("Unknown wallet type");return e}function Ms(e){if(e===o.Compression.COMPRESSION_GZIP)return"gzip";if(e===o.Compression.COMPRESSION_DEFLATE)return"deflate";throw new Error("unrecognized compression algorithm")}function xs(e,t=1024){let s=0;return new ReadableStream({pull(r){if(s>=e.length)return r.close();let n=s+t;n=n<=e.length?n:e.length,r.enqueue(e.subarray(s,n)),s=n}})}function _s(e,t){let s=0;return new WritableStream({write(r){const n=s+r.length;if(n>t)throw new Error("maximum output size exceeded");for(;e.bytes.length<n;)e.bytes=Vs(e.bytes,t);e.bytes.set(r,s),s=n},close(){s<e.bytes.length&&(e.bytes=e.bytes.subarray(0,s))}})}function Vs(e,t){let s=2*e.length;s>t&&(s=t);const r=new Uint8Array(s);return r.set(e),r}function Us(e){let t;try{t=u.ContactBundle.decode(e)}catch(s){const n=r.PublicKeyBundle.decode(e);t={v1:{keyBundle:new ce(n)},v2:void 0}}if(t.v1?.keyBundle)return new ce(t.v1.keyBundle);if(t.v2?.keyBundle)return new oe(t.v2.keyBundle);throw new Error("unknown or invalid contact bundle")}function Os(e){return e instanceof ce?u.ContactBundle.encode({v1:{keyBundle:e},v2:void 0}).finish():u.ContactBundle.encode({v1:void 0,v2:{keyBundle:e}}).finish()}var qs,Ls,Gs,Hs,Fs;class $s{constructor(e,t,s){this.value=e,this.entryType=t,this.permissionType=s}get key(){return`${this.entryType}-${this.value}`}static fromAddress(e,t="unknown"){return new $s(e,"address",t)}static fromGroupId(e,t="unknown"){return new $s(e,"groupId",t)}static fromInboxId(e,t="unknown"){return new $s(e,"inboxId",t)}}class js{constructor(e){this.entries=new Map,this.client=e}allow(e){const t=$s.fromAddress(e,"allowed");return this.entries.set(t.key,"allowed"),t}deny(e){const t=$s.fromAddress(e,"denied");return this.entries.set(t.key,"denied"),t}allowGroup(e){const t=$s.fromGroupId(e,"allowed");return this.entries.set(t.key,"allowed"),t}denyGroup(e){const t=$s.fromGroupId(e,"denied");return this.entries.set(t.key,"denied"),t}allowInboxId(e){const t=$s.fromInboxId(e,"allowed");return this.entries.set(t.key,"allowed"),t}denyInboxId(e){const t=$s.fromInboxId(e,"denied");return this.entries.set(t.key,"denied"),t}state(e){const t=$s.fromAddress(e);return this.entries.get(t.key)??"unknown"}groupState(e){const t=$s.fromGroupId(e);return this.entries.get(t.key)??"unknown"}inboxIdState(e){const t=$s.fromInboxId(e);return this.entries.get(t.key)??"unknown"}async decodeMessages(e){const t=Array.from(e.values()),{responses:s}=await this.client.keystore.selfDecrypt({requests:t.map((e=>({payload:e})))}),r=Array.from(e.keys()).map(((e,t)=>[e,s[t]])).reduce(((e,[t,s])=>{if(s.result?.decrypted){const r=y.PrivatePreferencesAction.decode(s.result.decrypted);e.set(t,r)}return e}),new Map);return await this.client.keystore.savePrivatePreferences(r),r}processActions(e){Array.from(e.values()).forEach((e=>{e.allowAddress?.walletAddresses.forEach((e=>{this.allow(e)})),e.denyAddress?.walletAddresses.forEach((e=>{this.deny(e)})),e.allowGroup?.groupIds.forEach((e=>{this.allowGroup(e)})),e.denyGroup?.groupIds.forEach((e=>{this.denyGroup(e)})),e.allowInboxId?.inboxIds.forEach((e=>{this.allowInboxId(e)})),e.denyInboxId?.inboxIds.forEach((e=>{this.denyInboxId(e)}))}))}async stream(e){const t=await this.client.keystore.getPrivatePreferencesTopic();return he.create(this.client,[t],(async e=>{if(!e.message||!e.timestampNs)return;const t=await this.decodeMessages(new Map([[e.timestampNs,e.message]]));return this.processActions(t),t.get(e.timestampNs)}),void 0,e)}reset(){this.entries.clear()}async load(e){const t=await this.client.keystore.getPrivatePreferencesTopic(),s=(await this.client.listEnvelopes(t,(async({message:e,timestampNs:t})=>[t,e]),{pageSize:500,direction:d.SortDirection.SORT_DIRECTION_ASCENDING,startTime:e})).filter((([e])=>Boolean(e)));await this.decodeMessages(new Map(s));const r=this.client.keystore.getPrivatePreferences();return this.reset(),this.processActions(r),this.entries}async publish(e){const t=e.reduce(((e,t)=>{let s,r,n;if("unknown"===t.permissionType)return e;switch(t.entryType){case"address":s="allowed"===t.permissionType?"allowAddress":"denyAddress",r="walletAddresses",n=e[s]?.[r]??[];break;case"groupId":s="allowed"===t.permissionType?"allowGroup":"denyGroup",r="groupIds",n=e[s]?.[r]??[];break;case"inboxId":s="allowed"===t.permissionType?"allowInboxId":"denyInboxId",r="inboxIds",n=e[s]?.[r]??[];break;default:return e}return{...e,[s]:{[r]:[...n,t.value]}}}),{}),s=await this.client.keystore.createPrivatePreference(t);await this.client.publishEnvelopes(s),this.client.keystore.savePrivatePreferences(new Map([[s[0].timestamp.getTime().toString(),t]])),e.forEach((e=>{this.entries.set(e.key,e.permissionType)}))}}class Xs{constructor(e){qs.add(this),Ls.set(this,void 0),Gs.set(this,void 0),this.addresses=new Set,this.client=e,wt(this,Ls,new js(e),"f"),wt(this,Gs,new ot("user-preferences",e.keystore),"f")}async loadConsentList(e){return pt(this,Gs,"f").run((async t=>{const s=await pt(this,Ls,"f").load(e??t);try{const e=(await this.client.conversations.list()).reduce(((e,t)=>t.consentProof&&"unknown"===this.consentState(t.peerAddress)&&pt(this,qs,"m",Hs).call(this,t.consentProof,t.peerAddress)?e.concat(t.peerAddress):e),[]);e.length&&await this.client.contacts.allow(e)}catch(e){console.log(e)}return s}))}async refreshConsentList(){return pt(this,Ls,"f").reset(),await pt(this,Gs,"f").resetLastRunTime(),this.loadConsentList()}async streamConsentList(e){return pt(this,Ls,"f").stream(e)}setConsentListEntries(e){e.length&&(pt(this,Ls,"f").reset(),e.forEach((e=>{"allowed"===e.permissionType&&pt(this,Ls,"f").allow(e.value),"denied"===e.permissionType&&pt(this,Ls,"f").deny(e.value)})))}isAllowed(e){return"allowed"===pt(this,Ls,"f").state(e)}isDenied(e){return"denied"===pt(this,Ls,"f").state(e)}isGroupAllowed(e){return"allowed"===pt(this,Ls,"f").groupState(e)}isGroupDenied(e){return"denied"===pt(this,Ls,"f").groupState(e)}isInboxAllowed(e){return"allowed"===pt(this,Ls,"f").inboxIdState(e)}isInboxDenied(e){return"denied"===pt(this,Ls,"f").inboxIdState(e)}consentState(e){return pt(this,Ls,"f").state(e)}groupConsentState(e){return pt(this,Ls,"f").groupState(e)}inboxConsentState(e){return pt(this,Ls,"f").inboxIdState(e)}async allow(e){await pt(this,Ls,"f").publish(e.map((e=>$s.fromAddress(e,"allowed"))))}async deny(e){await pt(this,Ls,"f").publish(e.map((e=>$s.fromAddress(e,"denied"))))}async allowGroups(e){await pt(this,Ls,"f").publish(e.map((e=>$s.fromGroupId(e,"allowed"))))}async denyGroups(e){await pt(this,Ls,"f").publish(e.map((e=>$s.fromGroupId(e,"denied"))))}async allowInboxes(e){await pt(this,Ls,"f").publish(e.map((e=>$s.fromInboxId(e,"allowed"))))}async denyInboxes(e){await pt(this,Ls,"f").publish(e.map((e=>$s.fromInboxId(e,"denied"))))}}Ls=new WeakMap,Gs=new WeakMap,qs=new WeakSet,Hs=function({signature:e,timestamp:t},s){const r=Number(t);if(!e||!r)return!1;if(r>Date.now())return!1;if(r<Date.now()-2592e6)return!1;const n=X(e),i=B(s,r),a=Z(v(b(i)),n);return a?.getEthereumAddress()===this.client.address},function(e){e[e.none=0]="none",e[e.xmtpTopicStore=1]="xmtpTopicStore"}(Fs||(Fs={}));const Js=Fs.none;class zs{static createConfiguration(){return{type:Js,version:0}}constructor(e){this.configuration=e}get backupType(){return Js}}const Ws=Fs.xmtpTopicStore;class Ys{static createConfiguration(e){return{type:Ws,version:0,topic:"history-v0:"+e}}constructor(e){this.configuration=e}get backupType(){return Ws}}async function Qs(e,t){const s=await async function(e,t){let s;switch((await t()).type){case Fs.none:s=zs.createConfiguration();break;case Fs.xmtpTopicStore:s=Ys.createConfiguration(e)}return s}(e,t);switch(s.type){case Fs.none:return new zs(s);case Fs.xmtpTopicStore:return new Ys(s)}}const{Compression:Zs}=o,er=104857600;class tr{constructor(e,t,s,r){this.knownPublicKeyBundles=new Map,this.keystore=r,this.publicKeyBundle=e,this.address=e.walletSignatureAddress(),this._conversations=new dt(this),this._codecs=new Map,this._maxContentSize=er,this.apiClient=t,this._backupClient=s,this.contacts=new Xs(this)}get conversations(){return this._conversations}get backupType(){return this._backupClient.backupType}get signedPublicKeyBundle(){return oe.fromLegacyBundle(this.publicKeyBundle)}static async create(e,t){const s=Ds(e),r=function(e){const t={privateKeyOverride:void 0,env:"dev",apiUrl:void 0,codecs:[new k],maxContentSize:er,persistConversations:!0,skipContactPublishing:!1,useSnaps:!1,basePersistence:"undefined"!=typeof window&&void 0!==window.document?ht.create():ut.create(),disablePersistenceEncryption:!1,keystoreProviders:ir(),apiClientFactory:sr};return e?.codecs&&(e.codecs=t.codecs.concat(e.codecs)),e?.useSnaps&&(e.keystoreProviders=[new Rs("npm:@xmtp/snap","1.3.6"),...t.keystoreProviders]),{...t,...e}}(t),n=r.apiClientFactory(r),i=await async function(e,t,s){for(const r of e.keystoreProviders)try{return await r.newKeystore(e,t,s??void 0)}catch(e){if(e instanceof lt)continue;throw e}throw new Error("No keystore providers available")}(r,n,s),a=new ce(await i.getPublicKeyBundle()),o=a.walletSignatureAddress();n.setAuthenticator(new je(i));const c=await tr.setupBackupClient(o,r.env),d=new tr(a,n,c,i);return await d.init(r),d}static async getKeys(e,t){const s=await tr.create(Ds(e),t),r=await s.keystore.getPrivateKeyBundle();return new Ge(r).encode()}static isSnapsReady(){return Ps()}static async setupBackupClient(e,t){return Qs(e,(async()=>Promise.resolve({type:"local"===t?Fs.xmtpTopicStore:Fs.none})))}async init(e){e.codecs.forEach((e=>{this.registerCodec(e)})),this._maxContentSize=e.maxContentSize,e.skipContactPublishing||await this.ensureUserContactPublished(e.publishLegacyContact)}async close(){}async ensureUserContactPublished(e=!1){const t=await rr(this.apiClient,this.address);t&&t instanceof oe&&this.signedPublicKeyBundle.equals(t)||(await this.publishUserContact(!0),e||await this.publishUserContact(e))}async publishUserContact(e=!1){const t=e?this.publicKeyBundle:this.signedPublicKeyBundle;await this.publishEnvelopes([{contentTopic:Ae(this.address),message:Os(t)}])}async getUserContact(e){e=m(e);const t=this.knownPublicKeyBundles.get(e);if(t)return t;const s=await rr(this.apiClient,e);return s&&this.knownPublicKeyBundles.set(e,s),s}async getUserContacts(e){const t=e.map((e=>m(e))),s=new Map,r=[];for(const e of t){const t=this.knownPublicKeyBundles.get(e);t?s.set(e,t):(s.set(e,void 0),r.push(e))}const n=await nr(this.apiClient,r);for(let e=0;e<n.length;e++){const t=r[e],i=n[e];s.set(t,i),i&&this.knownPublicKeyBundles.set(t,i)}return t.map((e=>s.get(e)))}forgetContact(e){e=m(e),this.knownPublicKeyBundles.delete(e)}async canMessage(e){try{if(Array.isArray(e)){return(await this.getUserContacts(e)).map((e=>!!e))}return void 0!==await this.getUserContact(e)}catch(e){return!1}}static async canMessage(e,t){const s=new at(t?.apiUrl||et[t?.env||"dev"],{appVersion:t?.appVersion});if(Array.isArray(e)){const t=e.map((e=>m(e)));return(await nr(s,t)).map((e=>!!e))}try{e=m(e)}catch(e){return!1}return void 0!==await rr(s,e)}validateEnvelope(e){const t=e.message;if(!e.contentTopic)throw new Error("Missing content topic");if(!t||!t.length)throw new Error("Cannot publish empty message")}async publishEnvelopes(e){for(const t of e)this.validateEnvelope(t);await this.apiClient.publish(e)}registerCodec(e){const t=e.contentType,s=`${t.authorityId}/${t.typeId}`;return this._codecs.set(s,e),this}codecFor(e){const t=`${e.authorityId}/${e.typeId}`,s=this._codecs.get(t);if(s&&!(e.versionMajor>s.contentType.versionMajor))return s}async encodeContent(e,t){const s=t?.contentType||K,r=this.codecFor(s);if(!r)throw new Error("unknown content type "+s);const n=r.encode(e,this),i=r.fallback(e);return i&&(n.fallback=i),"number"==typeof t?.compression&&n.content.length>=10&&(n.compression=t.compression),await async function(e){if(void 0===e.compression)return;const t={bytes:new Uint8Array(e.content.length/10)};await xs(e.content).pipeThrough(new CompressionStream(Ms(e.compression))).pipeTo(_s(t,e.content.length+1e3)),e.content=t.bytes}(n),{payload:o.EncodedContent.encode(n).finish(),shouldPush:r.shouldPush(e)}}async decodeContent(e){const t=o.EncodedContent.decode(e);if(!t.type)throw new Error("missing content type");let s;const r=new P(t.type);let n;await async function(e,t){if(void 0===e.compression)return;const s={bytes:new Uint8Array(e.content.length)};await xs(e.content).pipeThrough(new DecompressionStream(Ms(e.compression))).pipeTo(_s(s,t)),e.content=s.bytes}(t,1e3);const i=this.codecFor(r);return i?s=i.decode(t,this):n=new Error("unknown content type "+r),{content:s,contentType:r,error:n,contentFallback:t.fallback}}listInvitations(e){return this.listEnvelopes(Ce(this.address),(async e=>e),e)}async listEnvelopes(e,t,s){s||(s={});const{startTime:r,endTime:n,limit:i,pageSize:a}=s,o=await this.apiClient.query({contentTopic:e,startTime:r,endTime:n},{direction:s.direction||d.SortDirection.SORT_DIRECTION_ASCENDING,limit:i,pageSize:a}),c=[];for(const e of o)if(e.message)try{const s=await t(e);c.push(s)}catch(e){console.warn("Error in listEnvelopes mapper",e)}return c}listEnvelopesPaginated(e,t,s){return We(this.apiClient.queryIteratePages({contentTopic:e,startTime:s?.startTime,endTime:s?.endTime},{direction:s?.direction,pageSize:s?.pageSize||100}),t)}}function sr(e){const t=e.apiUrl||et[e.env];return new at(t,{appVersion:e.appVersion})}async function rr(e,t){const s=e.queryIterator({contentTopic:Ae(t)},{pageSize:5,direction:Ze.SORT_DIRECTION_DESCENDING});for await(const e of s){if(!e.message)continue;const s=Us(e.message);let r;try{r=await(s?.walletSignatureAddress())}catch(e){r=void 0}if(r?.toLowerCase()===t.toLowerCase())return s}}async function nr(e,t){const s=t.map(Ae),r=await e.batchQuery(s.map((e=>({contentTopic:e,pageSize:5,direction:Ze.SORT_DIRECTION_DESCENDING}))));return Promise.all(t.map((async(e,t)=>{const s=r[t];if(s)for(const t of s)if(t.message)try{const s=Us(t.message),r=await(s?.walletSignatureAddress());if(e.toLowerCase()===r.toLowerCase())return s;console.info("Received contact bundle with incorrect address")}catch(e){console.info("Invalid contact bundle",e)}})))}function ir(){return[new Ns,new ps,new ls]}export{et as ApiUrls,Ye as AuthCache,ht as BrowserStoragePersistence,R as Ciphertext,tr as Client,Zs as Compression,$s as ConsentListEntry,Re as ConversationV1,Ne as ConversationV2,dt as Conversations,Ve as DecodedMessage,as as EncryptedPersistence,at as HttpApiClient,rs as InMemoryKeystore,ut as InMemoryPersistence,Mt as InvitationV1,ls as KeyGeneratorKeystoreProvider,ft as LocalAuthenticator,xe as MessageV1,_e as MessageV2,ps as NetworkKeystoreProvider,os as PrefixedPersistence,W as PrivateKey,Ge as PrivateKeyBundleV1,Le as PrivateKeyBundleV2,ae as PublicKey,ce as PublicKeyBundle,Vt as SealedInvitation,ee as Signature,ie as SignedPublicKey,oe as SignedPublicKeyBundle,Rs as SnapProvider,Ze as SortDirection,Ns as StaticKeystoreProvider,he as Stream,ke as buildContentTopic,Pe as buildDirectMessageTopic,Se as buildDirectMessageTopicV2,Ae as buildUserContactTopic,Te as buildUserIntroTopic,Ce as buildUserInviteTopic,Ie as buildUserPrivateStoreTopic,fe as dateToNs,Us as decodeContactBundle,Oe as decodeContent,V as decrypt,ir as defaultKeystoreProviders,_ as encrypt,H as exportHmacKey,ve as fromNanoString,L as generateHmacSignature,q as hkdfHmacKey,F as importHmacKey,Cs as keystoreApiDefs,We as mapPaginatedStream,me as nsToDate,ze as retry,Is as snapKeystoreApiDefs,ge as toNanoString,G as verifyHmacSignature};
//# sourceMappingURL=index.js.map
